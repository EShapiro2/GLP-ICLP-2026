\section{Implementation}\label{section:implementation}

The implementation of GLP on smartphones requires cross-platform mobile deployment, garbage-collected memory management, lightweight concurrency, cryptographic operations, and TEE attestation access. The Dart programming language~\cite{dartIsolates}, deployed via Flutter~\cite{flutter}, satisfies these requirements. Flutter compiles to native iOS and Android applications from a single codebase, while Dart's event loop with microtask scheduling maps naturally to GLP's operational semantics. Flutter plugins provide access to Google Play Integrity~\cite{googlePlayIntegrity} and Apple App Attest~\cite{appleAppAttest}, enabling TEE-based peer verification. Server infrastructure supports initial attestation and NAT traversal via STUN~\cite{rfc5389}, TURN~\cite{rfc5766}, and ICE~\cite{rfc8445}, but core GLP execution remains peer-to-peer on smartphones.
While React Native~\cite{react2024native} and Kotlin Multiplatform~\cite{kotlin2024multiplatform} are popular alternatives, they lack either Dart's concurrency model~\cite{dartIsolates} or Flutter's unified cross-platform deployment with TEE access~\cite{flutter}, both essential for implementing GLP's multiagent semantics with attestation.


\mypara{Secure implementation on smartphones}
On current smartphones, secure multiagent GLP is realized through Trusted Execution Environments (TEEs) with hardware providers (e.g., ARM TrustZone~\cite{pinto2019demystifying}) as trust anchors, combined with OS-level attestation services (Google Play Integrity~\cite{googlePlayIntegrity}, Apple App Attest~\cite{appleAppAttest}) with OS providers as trust anchors. This infrastructure authenticates and attests to the integrity of the sender and prevents tampering while ensuring confidentiality.


\mypara{Architecture}
The Dart implementation maps the formal `implementation-ready' multiagent GLP semantics (detailed in Appendix~\ref{appendix:IR-maGLP}) to concrete smartphone operations. Each agent maintains its resolvent as Dart microtasks with three goal categories: active (queued for reduction), suspended (awaiting variable assignments), and failed (permanently blocked). A shared variable table tracks creator-holder relationships for distributed variables, enabling message routing without consensus protocols.

The implementation preserves GLP's three core transactions. \textbf{Reduce} performs goal/clause reduction within Dart microtasks, generating assignments for remote readers that enter the message queue $M_p$. \textbf{Communicate} delivers these assignments across agents via encrypted, signed, and attested messages routed through variable creators, with the Dart event loop processing received messages and updating the variable table $V_p$. \textbf{Network} handles initial channel establishment for cold calls using platform-specific APIs (WebRTC for peer-to-peer, HTTPS for NAT traversal). The single-reader/single-writer invariant eliminates distributed unification and is enforced through exclusive variable table tracking, while creator-mediated routing ensures messages reach their destinations despite variable migration. Variable abandonment detection runs as a periodic microtask, scanning for unreachable variables and generating appropriate abandonment messages.

\mypara{Security}  Security enforcement occurs at message boundaries as specified in Section~\ref{section:secturemaGLP}. While the formal specification in Appendix~\ref{appendix:irmaGLP} requires attestation, signature and encryption for every message, practical implementations employ the standard cryptographic optimizations described in Section~\ref{section:secturemaGLP}—including intermittent attestation verification and session-key-based channels—to reduce computational overhead while maintaining security guarantees. 

