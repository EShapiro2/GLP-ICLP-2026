%==============================================================================
\section{Multiagent GLP}\label{sec:maglp}
%==============================================================================

This section extends GLP to multiple agents. We first define multiagent transition systems via multiagent atomic transactions, then define multiagent GLP (maGLP) as a transactions-based multiagent transition system, and finally show how the social graph operates in the multiagent setting.

%------------------------------------------------------------------------------
\subsection{Multiagent Transition Systems}
\label{sec:mts}
%------------------------------------------------------------------------------

We assume a potentially infinite set of \emph{agents} $\Pi$, considering only finite subsets. A \emph{multiagent transition system} over agents $P \subset \Pi$ and local states $S$ assigns each agent its own local state; a \emph{configuration} is a tuple of local states indexed by agents; and \emph{atomic transactions} change the local states of their \emph{active participants} while others remain stationary. A \emph{transactions-based} multiagent transition system is fully specified by a set of atomic transactions of bounded degree, with the $P$-closure operation lifting transactions over subsets $Q \subseteq P$ to transitions over all of $P$. The formal definitions appear in Appendix~\ref{appendix:mts-defs}.

%------------------------------------------------------------------------------
\subsection{From GLP to Multiagent GLP}
\label{sec:glp-to-maglp}
%------------------------------------------------------------------------------

In extending GLP to multiple agents, each agent maintains its own asynchronous resolvent as its local state. The key insight is that GLP's variable pairs provide natural binary communication channels: when agent $p$ binds a writer $X$ for which the paired reader $X?$ is held by agent $q$, the assignment $X := T$ must be communicated to $q$.

A key difference between single-agent GLP and multiagent GLP is in the initial state. In a multiagent transition system all agents must have the same initial local state $s0$ (Definition~\ref{definition:mts}). This precludes setting up an initial configuration in which agents share logic variables, as this would imply different initial states for different agents.

We resolve this in two steps. First, we employ only anonymous logic variables ``\verb|_|'' in the initial local states of agents: Anonymous variables are, on the one hand, syntactically identical, hence allow all initial states to be syntactically identical, and on the other hand represent unique variables, hence semantically all initial goals have unique, local, non-shared variables. The initial state of all agents is the atomic goal \verb|agent(ch(_?,_),ch(_?,_))|, with the first channel serving communication with the user and the second with the network.

Second, the Cold-call transaction enables agents to bootstrap communication by establishing shared variables through the network infrastructure, realizing the cold-call protocol for connecting previously-disconnected agents.

%------------------------------------------------------------------------------
\subsection{Multiagent GLP Definition}
\label{sec:maglp-def}
%------------------------------------------------------------------------------

\begin{definition}[Multiagent GLP]\label{definition:maGLP}
Given agents $P\subset \Pi$ and GLP program $M$, the \temph{maGLP transition system} over $P$ and $M$ is the transactions-based multiagent transition system (Definition~\ref{definition:tbmts}) over $P$, local states being asynchronous resolvents over $M$, initial local state $s0 = (\{\verb|agent(ch(_?,_),ch(_?,_))|\}, \emptyset)$, and the following transactions $c\rightarrow c'$:
\begin{enumerate}
    \item \textbf{Reduce $p$:} A unary transaction with participant $p$ where $c_p\rightarrow c'_p$ is a GLP Reduce transition (Definition~\ref{def:glp-ts}).
    
    \item \textbf{Communicate $p$ to $q$:} A transaction with participants $p,q\in P$ where $c_p=(G_p,\sigma_p)$, $c_q=(G_q,\sigma_q)$, $\{X?:=T\} \in \sigma_p$, $X?$ occurs in $G_q$, $c'_p=(G_p,\sigma_p \setminus \{X?:=T\})$, and $c'_q=(G_q\{X?:=T\},\sigma_q)$. 
    
    \item \textbf{Cold-call $p$ to $q$:} A binary transaction with participants $p\ne q \in P$ where the network output stream in $c_p$ has a new message \verb|msg|$(q,X)$, $c'_p$ is the result of advancing the network output stream in $c_p$, and $c'_q$ is the result of adding $X?$ to the network input stream in $c_q$.
\end{enumerate}
\end{definition}

Note that Communicate maybe unary or binary, depending on whether $p=q$.  Both Communicate and Cold-call transfer assignments from writers to readers: Communicate operates between agents sharing a paired reader and writer, while Cold-call operates through the network streams established in each agent's initial configuration, enabling the creation of paired variables among previously-disconnected agents.
Naturally, Cold-call would be the exception, as once agents share a paired variable they do not need to communicate; moreover, an agent with two friends (with which it shares channels) may introduce them to each other, also saving the need for a Cold-call.
%------------------------------------------------------------------------------
\subsection{The Multiagent Social Graph}
\label{sec:ma-social-graph}
%------------------------------------------------------------------------------

The social graph agent code presented in Section~\ref{sec:social-graph} runs unchanged in maGLP. The only difference is the boot code: the network switch is replaced by maGLP's Cold-call transaction, and each agent runs on a separate isolate. Two boot variants are presented in Appendix~\ref{appendix:social-graph-complete}: a headless boot with actors (Appendix~\ref{app:maglp-boot}) and an interactive UI boot (Appendix~\ref{app:maglp-ui-boot}).

When Alice executes the cold-call protocol to befriend Bob, her agent sends \verb|msg(bob, intro(alice, Resp))| on the \verb|'_net'| output stream. The Cold-call transaction (Definition~\ref{definition:maGLP}) transfers this message to Bob's network input stream, adding the reader \verb|Resp?| to Bob's resolvent. When Bob accepts, binding \verb|Resp| to \verb|accept(ch(FIn?, FOut))|, the Communicate transaction transfers this binding back to Alice.

Similarly, friend-mediated introduction works through Communicate transactions: when Bob introduces Alice to Charlie, the channel pair he creates contains readers that are transferred to Alice and Charlie via Communicate, establishing their direct connection.

The network switch in the concurrent GLP version (Section~\ref{sec:social-graph}) is thus a faithful simulation of maGLP's Cold-call transaction, allowing single-process testing of multiagent protocols.

%------------------------------------------------------------------------------
\subsection{Safety Properties of maGLP}
\label{sec:maglp-safety}
%------------------------------------------------------------------------------

The safety properties established for single-agent GLP extend to maGLP.

\begin{restatable}[Safety Properties of maGLP]{proposition}{propMaGLPSafety}
\label{proposition:maGLP-safety}
The safety properties established for GLP in Section~\ref{sec:glp} extend to maGLP:
\begin{enumerate}
\item \textbf{SO Preservation} (cf.\ Proposition~\ref{prop:so-preservation}): If the initial goals of all agents satisfy SO, then every goal in every agent's resolvent throughout the run satisfies SO.
\item \textbf{Monotonicity} (cf.\ Proposition~\ref{prop:glp-monotonicity}): If unit goal $A$ in agent $p$'s resolvent can reduce with clause $C$ at step $i$, then at any step $j > i$, either $A$ has been reduced or there exists $A'$ in $p$'s resolvent where $A' = A\tau$ for some reader substitution $\tau$, and $A'$ can reduce with $C$.
\end{enumerate}
\end{restatable}

\begin{restatable}[maGLP Computation is Deduction]{proposition}{propMaGLPDeduction}
\label{prop:maglp-deduction}
Let $L$ be the transition system whose resolvent is the union of all local resolvents, the initial goal includes a \verb|network| goal with channels paired to each agent's network channels, and the program is $M$ augmented with the GLP definition of \verb|network|. Then maGLP runs correspond to GLP runs of $L$, and their outcomes are logical consequences of the augmented program.
\end{restatable}

\begin{restatable}[maGLP Persistence]{lemma}{lemmaGLPPersistence}
\label{lem:maglp-persistence}
maGLP is persistent.
\end{restatable}

Proofs appear in Appendix~\ref{appendix:proofs}.

\begin{definition}[maGLP Fair Run]
\label{def:maglp-fair-run}
A complete maGLP run is \temph{fair} if every transaction that becomes enabled is eventually taken.
\end{definition}

\mypara{Implementation}
The implementation-ready variants of GLP and maGLP, along with formal correctness proofs that they implement their respective specifications, are presented in a companion paper~\cite{shapiro2026implementing}.
