\section{Introduction}

A digital platform is \emph{grassroots}~\citep{shapiro2023grassrootsBA} if it can have multiple instances that can (1) operate independently of each other and of any global resource other than the network, and (2) coalesce into ever larger instances, possibly resulting in a single global instance.
Grassroots platforms that have been specified (but not yet implemented) include the grassroots social graph~\citep{shapiro2025atomic}, grassroots social networks~\citep{shapiro2023gsn}, grassroots cryptocurrencies~\citep{shapiro2024gc,lewis2023grassroots}, and grassroots federation~\citep{shapiro2025GF}. The Scuttlebutt protocol and social network~\citep{kermarrec2020gossiping} is perhaps the sole example of a deployed grassroots platform.

Here, we present Grassroots Logic Programs (GLP), a multiagent, concurrent, logic programming language, designed for the implementation of smartphone-based, serverless, grassroots platforms.  First we present Concurrent GLP as a variation on Logic Programs (LP)~\citep{lloyd1987foundations}.  Syntactically, GLP adds to LP (1) \textbf{Readers:} Each logic variable (now referred to as \emph{writer}) is paired with a \emph{reader}~\citep{levi1985readonly}, which is assigned a value only once its paired writer is assigned that value;  (2) \textbf{Single-Occurrence (SO):} A variable may occur at most once in a goal or a clause; and (3) \textbf{Single-Reader Single-Writer (SRSW):} A writer occurs in a clause iff its paired reader occurs in the clause.  
The operational semantics of GLP is a variation on that of LP, which preserves the concept of computation-as-deduction~\citep{kowalski1974predicate}, yet conjures both linear logic~\citep{girard1987linear} and futures/promises~\citep{friedman1976impact}: An assignment to a variable may be produced at most once, via the sole occurrence of a writer (promise), and consumed at most once, via the sole occurrence of its paired reader (future). We illustrate Concurrent GLP via a simulation of a grassroots social graph, in which agents may initiate friendships (bidirectional communication channels) via ``cold-calls'' as well as introduce mutual friends to each other, via a simulated network switch.

Then, we present multiagent transition systems and their specification via multiagent atomic transactions, and use them to define multiagent GLP (maGLP), where the key challenge is realizing ``cold-calls'':  How can two agents in disconnected components of the social graph become the owners of paired logic variables?  maGLP extends GLP with (1) \textbf{Multiagents:}  Named agents that operate independently while communicating to remote readers assignments made to paired local writers;  (2) \textbf{Cold-calls:} A means for sending a term with variables to a named agent while retaining their paired variables locally.  We then present an maGLP implementation of the social graph in which the network-simulator is replaced by maGLP's Cold-call transaction, and social cold-calls among agents are realised by maGLP cold-calls among these agents.

Lastly, we recall the definition of grassroots platforms~\citep{shapiro2023grassrootsBA} and how to prove that a platform specified via atomic transactions is grassroots~\citep{shapiro2025atomic}, and apply these to prove that maGLP is indeed grassroots.

\mypara{Programming grassroots platforms}
A key challenge in implementing grassroots platforms is overcoming faulty and malicious participants~\citep{lamport1982byzantine}. Without secure language support, correct participants cannot reliably identify each other, establish secure communication channels, or verify each other's code integrity~\citep{sabt2015trusted,costan2016intel}.
While grassroots platforms have been formally specified and their properties proven~\citep{shapiro2023grassrootsBA,shapiro2023gsn,shapiro2024gc,shapiro2025GF,shapiro2025atomic}, they remain mathematical constructions without actual implementations. To the best of our knowledge, no existing programming language provides the necessary combination of distributed execution, cryptographic security, safety, and liveness guarantees required to realize these specifications. GLP aims to close the gap between mathematical specification and implementation of grassroots platforms.

\mypara{Paper outline}
Section~\ref{sec:glp} presents Concurrent GLP: transition systems, logic programs as transition systems, GLP extending LP with readers, operational semantics, guards, programming examples, and the grassroots social graph simulation. Section~\ref{sec:maglp} extends to multiagent GLP: multiagent transition systems, the maGLP definition, and the multiagent social graph. Section~\ref{sec:grassroots} proves maGLP is grassroots. Section~\ref{section:related-work} reviews related work, and Section~\ref{section:conclusion} concludes. A companion paper~\citep{shapiro2026types} develops a moded type system for GLP, and another~\citep{shapiro2026implementing} provides implementation-ready operational semantics with correctness proofs.
