%==============================================================================
\section{Concurrent GLP}
\label{sec:glp}
%==============================================================================

This section presents Grassroots Logic Programs (GLP), a concurrent logic programming language. We begin with transition systems, then define GLP. Standard LP definitions are recalled in \ref{appendix:lp}. We illustrate GLP with programming examples and conclude with the grassroots social graph---the foundational platform that all other grassroots platforms build upon.

%------------------------------------------------------------------------------
\subsection{Transition Systems}
\label{sec:ts}
%------------------------------------------------------------------------------

\begin{definition}[Transition System]
\label{def:ts}
A \temph{transition system} is a tuple $TS = (C, c_0, T)$ where $C$ is an arbitrary set of \temph{configurations}, $c_0 \in C$ is a designated \temph{initial configuration}, and $T \subseteq C \times C$ is a \temph{transition relation}, with transitions written $c \rightarrow c' \in T$.
A transition $c \rightarrow c' \in T$ is \temph{enabled} from configuration $c$. A configuration $c$ is \temph{terminal} if no transitions are enabled from $c$. A \temph{computation} is a (finite or infinite) sequence of configurations where for each two consecutive configurations $(c,c')$ in the sequence, $c \rightarrow c' \in T$. A \temph{run} is a computation starting from $c_0$, which is \temph{complete} if it is infinite or ends in a terminal configuration.
\end{definition}

%------------------------------------------------------------------------------
\subsection{GLP: Extending LP with Readers}
\label{sec:glp-ext}
%------------------------------------------------------------------------------

Grassroots Logic Programs (GLP) extend LP by (1) adding a paired \emph{reader} $X?$ to every ``ordinary'' logic variable $X$, now called a \emph{writer}; (2) restricting variables in goals and clauses to have at most a single occurrence (SO); and (3) requiring that a variable occurs in a clause iff its paired variable also occurs in it (single-reader single-writer, SRSW). The result eschews unification in favour of simple term matching, is linear-logic-like~\citep{girard1987linear}, and is futures/promises-like~\citep{friedman1976impact}: each assignment $X := T$ is produced at most once via the sole occurrence of a writer (promise) $X$, and consumed at most once via the sole occurrence of its paired reader (future) $X?$.

\begin{definition}[GLP Variables]
\label{def:glp-variables}
Let $\calV$ denote the set of LP variables (identifiers beginning with uppercase), henceforth called \temph{writers}. Define $\calV? = \{X? \mid X \in \calV\}$, called \temph{readers}. The set of all GLP variables is $\hat\calV = \calV \cup \calV?$. A writer $X$ and its reader $X?$ form a \temph{variable pair}.
\end{definition}

GLP terms, unit goals, goals, and clauses are as in standard LP (\ref{appendix:lp}) but defined over the variables in $\hat\calV$.

\begin{definition}[Single-Occurrence (SO) Invariant]
\label{def:so-invariant}
A term, goal, or clause satisfies the \temph{single-occurrence (SO) invariant} if every variable occurs in it at most once.
\end{definition}

\begin{definition}[GLP Program, Goals]
\label{def:glp-program}
A clause $C$ satisfies the \temph{single-reader/single-writer (SRSW) restriction} if it satisfies SO and a variable occurs in $C$ iff its paired variable also occurs in $C$.
A \temph{GLP program} is a finite set of clauses satisfying SRSW; clauses for the same predicate form a \temph{procedure}.
The set of GLP goals $\hat\calG(P)$ includes all goals over $\hat\calV$ and the vocabulary of $P$that satisfy SO.
\end{definition}

\begin{example}[Fair Merge]
\label{ex:merge}
Consider the quintessential concurrent logic program for fairly merging two streams, written in GLP:
\begin{verbatim}
Stream ::= [] ;[_|Stream].


procedure merge(Stream?, Stream?, Stream).
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge(Xs, [], Xs?).
merge([], Ys, Ys?).
\end{verbatim}
and the goal \verb=merge([1,2,3|Xs?],[a,b|Ys?],Zs)=. Both the goal and each clause satisfy SO, and each clause satisfies SRSW. The first two clauses swap inputs in recursive calls, ensuring fairness when both streams are available.
\end{example}


As we shall see (Proposition~\ref{prop:so-preservation}), the SO invariant is maintained by the SRSW restriction: reducing a goal satisfying SO with a clause satisfying SRSW results in a goal satisfying SO. The purpose of the SRSW restriction is to prevent multiple writer occurrences racing to assign a variable.

%------------------------------------------------------------------------------
\subsection{GLP Operational Semantics}
\label{sec:glp-operational}
%------------------------------------------------------------------------------

\begin{definition}[Writers Substitution, Assignment, Readers Substitution and Counterpart]
\label{def:writers-assignment}
A GLP \temph{writer assignment} is a term of the form $X := T$, $X\in\calV$, $T\notin\calV$, satisfying SO. Similarly, a GLP \temph{reader assignment} is a term of the form $X? := T$, $X?\in\calV?$, $T\notin\calV$, satisfying SO. A \temph{writers (readers) substitution} $\sigma$ is the substitution implied by a set of writer (reader) assignments that jointly satisfy SO. Given a writers assignment $X := T$, its \temph{readers counterpart} is $X? := T$, and given a writers substitution $\sigma$, its \temph{readers counterpart} $\sigma?$ is the readers substitution defined by $X?\sigma? = X\sigma$.
\end{definition}

\begin{definition}[GLP Renaming, Renaming Apart]
\label{def:glp-renaming}
A \temph{GLP renaming} is a substitution $\rho: \hat\calV \to \hat\calV$ such that for each $X \in \calV$: $X\rho \in \calV$ and $X?\rho = (X\rho)?$. Two GLP terms \temph{have a variable in common} if for some writer $X \in \calV$, either $X$ or $X?$ occurs in both. A GLP renaming $\sigma$ \temph{renames $T'$ apart from} $T$ if $T'\sigma$ and $T$ have no variable in common.
\end{definition}

\begin{definition}[Writer MGU]
\label{def:writer-mgu}
Given two GLP unit goals $A$ and $H$, a \temph{writer mgu} is a writers substitution $\sigma$ such that $A\sigma = H\sigma$ and $\sigma$ is most general among such substitutions. Unlike standard unification, writer mgu only assigns writers, not readers.
\end{definition}

\begin{definition}[GLP Goal/Clause Reduction]
\label{def:glp-reduction}
Given GLP unit goal $A$ and clause $C$, with $H$ \verb|:-| $B$ being the result of the GLP renaming of $C$ apart from $A$, the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$ if $A$ and $H$ have a writer mgu.
\end{definition}

\begin{definition}[GLP Transition System]
\label{def:glp-ts}
Given a GLP program $P$, an \temph{asynchronous resolvent} over $P$ is a pair $(G, \sigma)$ where $G \in \hat\calG(P)$ and $\sigma$ is a readers substitution.

A transition system $GLP(P) = (\calC, c_0, \calT)$ is a \temph{GLP transition system} over $P$ and initial goal $G_0$ satisfying SO if:
\begin{enumerate}
    \item $\calC$ is the set of all asynchronous resolvents over $P$
    \item $c_0 = (G_0, \emptyset)$
    \item $\calT$ is the set of all transitions $(G, \sigma) \rightarrow (G', \sigma')$ satisfying either:
    \begin{enumerate}
        \item \textbf{Reduce:} there exists unit goal $A \in G$ such that $C \in P$ is the first clause for which the GLP reduction of $A$ with $C$ succeeds with result $(B, \hat\sigma)$, $G' = (G \setminus \{A\} \cup B)\hat\sigma$, and $\sigma' = \sigma \circ \hat\sigma?$
        \item \textbf{Communicate:} $\{X? := T\} \in \sigma$, $X?\in G$, $G' = G\{X? := T\}$, and $\sigma' = \sigma$
    \end{enumerate}
\end{enumerate}
\end{definition}

GLP Reduce differs from LP in (1) the use of a writer mgu instead of a regular mgu and (2) the choice of the first applicable clause instead of any clause. The first is the fundamental use of GLP readers for communication and synchronization. The second compromises on the or-nondeterminism of LP to allow writing fair concurrent programs, such as fair merge above. Note that or-nondeterminism is not completely eliminated, as different scheduling of arrival of assignments on the two input streams of \verb|merge| may result in different orders in its output stream.

The GLP Communicate rule realizes the use of reader/writer pairs for asynchronous communication: it communicates an assignment from its writer to its paired reader.


\mypara{Monotonicity}
Key differences between LP and GLP relate to monotonicity. In LP, if a goal cannot be reduced, it will never be reduced. In GLP, a goal that cannot be reduced now may be reduced in the future: if $A$ and $H$ have an mgu that writes on a reader $X? \in A$, and therefore have no writer mgu at present,  another goal that has $X$ may reduce, assigning $X$, and later $X?$, to a value that will allow $A$ and $H$ to have a writer mgu. Conversely, in LP, if a goal $A$ can be reduced now with some clause $H$\verb|:-|$B$, with a regular mgu of $A$ and $H$, it may not be reducible in the future due to variables that $A$ shares with other goals being assigned values by reductions of other goals, preventing unification between the instantiated $A$ and $H$. In GLP, if a goal $A$ can be reduced now (with a writers mgu), it can always be reduced in the future, as the SO invariant ensures that no other goal can assign any writer in $A$.

Implementation-wise, if a GLP goal $A$ cannot be reduced now, but there is a readers substitution $\sigma$ such that $A\sigma$ can be reduced, such readers are identified, the goal $A$ \emph{suspends} on these readers, and is rescheduled for another reduction attempt once any of them is assigned.

Despite these differences, GLP adopts the same notions of proper run, successful run, and outcome as LP (Definition~\ref{def:proper-run}, \ref{appendix:lp}), and has the same notion of logical consequence as LP. Let $/?$ be an operator that replaces every reader by its paired writer.

\begin{restatable}[GLP Computation is Deduction]{proposition}{propGLPDeduction}
\label{prop:glp-deduction}
Let $(G_0$ \texttt{:-} $G_n)\sigma$ be the outcome of a proper GLP run $\rho: (G_0,\sigma_0) \rightarrow \cdots \rightarrow (G_n, \sigma_n)$ of $GLP(P)$. Then $(G_0$ \texttt{:-} $G_n)\sigma/?$ is a logical consequence of $P/?$.
\end{restatable}

We note two additional safety properties of GLP runs.

\begin{restatable}[SO Preservation]{proposition}{propSOPreservation}
\label{prop:so-preservation}
If the initial goal $G_0$ satisfies SO, then every goal in the GLP run satisfies SO.
\end{restatable}

\begin{restatable}[Monotonicity]{proposition}{propMonotonicity}
\label{prop:glp-monotonicity}
In any GLP run, if unit goal $A$ can reduce with clause $C$ at step $i$, then either an instance of $A$ has been reduced by step $j > i$, or an instance of $A$ can still reduce with $C$ at step $j$.
\end{restatable}

\begin{definition}[Persistent Transition System]
\label{def:persistent}
A transition system is \temph{persistent} if every enabled transition remains enabled until taken.
\end{definition}

\begin{restatable}[GLP Persistence]{lemma}{lemPersistence}
\label{lem:persistence}
GLP is persistent.
\end{restatable}

\begin{definition}[Fair Run]
\label{def:fair-run}
A complete GLP run is \temph{fair} if every transition that becomes enabled is eventually taken.
\end{definition}

The SO invariant of GLP allows eschewing unification in favour of \emph{term matching}: if two terms that jointly satisfy SO are unifiable, their mgu maps each variable in one term to a subterm of the other. Term matching thus performs joint term-tree traversal and collects variable assignments along the way; the detailed definition and table appear in \ref{appendix:term-matching}.

%------------------------------------------------------------------------------
\subsection{Guards}
\label{sec:guards}
%------------------------------------------------------------------------------

GLP clauses may include \emph{guards}---tests that determine clause applicability.

\begin{definition}[Guarded Clause]
\label{def:guarded-clause}
A \temph{guarded clause} has the form $H$ \verb|:-| $G$ \verb"|" $B$, where $H$ is the head, $G$ is a conjunction of guard predicates, and $B$ is the body. The guard separator ``\verb"|"'' distinguishes guards from the body, and is interpreted logically as a conjunction.  Guard arguments are readers paired to head writers.
\end{definition}

Guards have three-valued semantics. Each guard predicate explicitly defines its \emph{success} condition. A guard \emph{suspends} if it does not succeed but some instance of it under a readers substitution would succeed. A guard \emph{fails} if no such instance exists. A guard conjunction succeeds if all members succeed; it suspends if any member suspends and none fail; it fails if any member fails.

Definition~\ref{def:glp-reduction} of a GLP goal/clause reduction is augmented to succeed if the guard also succeeds.

\begin{remark}[Guards and SRSW]
\label{rem:guards-srsw}
Guard occurrences count toward SRSW satisfaction: if $X?$ occurs in a guard, its paired writer $X$ must occur in the head and $X?$ may additionally occur once in the body.

Furthermore, if the success of a guard implies that $X?$ is ground, then $X?$ as well as $X$ may occur multiple times in the clause. Groundness-implying guards include \verb|ground|, \verb|integer|, \verb|number|, \verb|string|, \verb|constant|, arithmetic comparisons (\verb|<|, \verb|>|, \verb|=<|, \verb|>=|, \verb|=:=|, \verb|=\=|), and ground equality (\verb|=?=|). However,  \verb|known| and \verb|compound| do not imply groundness.
\end{remark}

\begin{remark}[Anonymous Variables]
\label{rem:anonymous-variables}
An \emph{anonymous variable} is any variable whose name begins with \verb|_| (e.g., \verb|_|, \verb|_In?|, \verb|_Out|). Anonymous writers may appear in the head, denoting a fresh writer with no paired reader, so that a value assigned to it is discarded. These provide a controlled exception to the SRSW restriction, allowing a process to abandon an input (e.g.\ an input stream) they are no longer interested in.
\end{remark}

Guard predicates include type tests (\verb|integer|, \verb|number|, \verb|string|, \verb|constant|, \verb|compound|, \verb|ground|, \verb|known|), arithmetic comparisons (\verb|<|, \verb|>|, \verb|=<|, \verb|>=|, \verb|=:=|, \verb|=\=|), and ground equality (\verb|=?=|). The full specification of guards and system predicates appears in \ref{appendix:guards-system}.

%------------------------------------------------------------------------------
\subsection{Programming Examples}
\label{sec:examples}
%------------------------------------------------------------------------------

Additional programming examples---including stream distribution, association list lookup, channel abstractions, stream tagging, cooperative production, and metainterpreters---appear in \ref{appendix:additional-techniques}.

%------------------------------------------------------------------------------
\subsection{The Grassroots Social Graph}
\label{sec:social-graph}
%------------------------------------------------------------------------------

The grassroots social graph is the foundational platform upon which all other grassroots platforms are built. Nodes represent cryptographically-identified agents; edges represent authenticated bidirectional channels; connected components arise spontaneously through befriending. We present the social graph as a single-agent GLP program, using a \emph{network switch} to simulate communication between agents, before introducing multiagent GLP in Section~\ref{sec:maglp}.

Each agent processes messages from user and network input streams and maintains an outputs list mapping named destinations to output streams. The program supports three protocols: (1) \emph{cold-call befriending}, where agents with no prior shared variables establish friendship by exchanging a response variable through the network; (2) \emph{text messaging} between established friends via named output streams; and (3) \emph{friend-mediated introduction}, where a mutual friend creates a channel pair and sends each half to the respective parties, establishing a direct connection.

A network switch process routes messages between agents in simulation; in deployment, it is replaced by maGLP's Cold-call transaction (Section~\ref{sec:maglp}). The detailed walkthrough with code, figures, and a comprehensive scenario involving Alice, Bob, and Charlie appears in \ref{appendix:social-graph-walkthrough}. The complete program---helper predicates, actor implementations, and boot variants---appears in \ref{appendix:social-graph-complete}.
