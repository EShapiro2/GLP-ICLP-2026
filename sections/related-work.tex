\section{Related Work}\label{section:related-work}

\mypara{Concurrent Logic Programming}
GLP belongs to the family of concurrent logic programming (CLP) languages that emerged in the 1980s: Concurrent Prolog~\citep{shapiro1983subset}, GHC~\citep{ueda1986guarded}, and PARLOG~\citep{clark1986parlog}. These languages interpret goals as concurrent processes communicating through shared logical variables, using committed-choice execution with guarded clauses. Shapiro's comprehensive survey~\citep{shapiro1989family} documents this family and its design space.

A key evolution was \emph{flattening}: restricting guards to primitive tests only. Flat Concurrent Prolog (FCP)~\citep{mierowsky1985fcp} and Flat GHC~\citep{ueda1986guarded} demonstrated that flat guards suffice for practical parallel programming while dramatically simplifying semantics and implementation.

GLP can be understood as \textbf{Flat Concurrent Prolog with the Single-Reader Single-Writer (SRSW) constraint}. FCP introduced read-only annotations (\verb|?|) distinguishing readers from writers of shared variables, enabling dataflow synchronization. However, read-only unification proved semantically problematic: Levi and Palamidessi~\citep{levi1985readonly} showed it is order-dependent, and Mierowsky et al.~\citep{mierowsky1985fcp} documented non-modularity issues. GHC dispensed with read-only annotations entirely, relying on guard suspension semantics.

GLP's SRSW constraint---requiring that each variable has exactly one writer and one reader occurrence---resolves these difficulties by ensuring that (1) no races occur on variable binding, and (2) term matching suffices, eschewing unification entirely. The result is a cleaner semantic foundation while preserving the expressiveness of stream-based concurrent programming. GLP retains logic programming's metaprogramming capabilities~\citep{safra1988meta,lichtenstein1988concurrent,shapiro1984systems}, essential for platform tooling development.

\mypara{Modes in Concurrent Logic Programming}
Mode systems for CLP have a rich history. PARLOG used mode declarations at the predicate level, with input modes enforcing one-way matching. Ueda's work on moded Flat GHC~\citep{ueda1994moded,ueda1995io} is most directly relevant: his mode system assigns polarity to every variable occurrence (positive for input/read, negative for output/write), with the \emph{well-modedness} property guaranteeing each variable is written exactly once. Ueda's subsequent linearity analysis~\citep{ueda2001resource} identifies variables read exactly once, enabling compile-time garbage collection. GLP enforces both single-reader and single-writer universally as a syntactic restriction, whereas Ueda's system guarantees single-writer with single-reader as an optional refinement.

\mypara{Linear logic and futures/promises}
GLP's SRSW constraint has deep connections to two foundational ideas. Girard's linear logic~\citep{girard1987linear} introduced the principle that resources must be used exactly once; GLP's single-writer/single-reader restriction enforces this at the variable level, ensuring each assignment is produced exactly once and consumed exactly once. Friedman and Wise's futures and promises~\citep{friedman1976impact} introduced placeholders for values computed asynchronously; GLP's reader/writer pairs realize this pattern, with the writer as promise (single producer) and reader as future (single consumer). The Caires-Pfenning-Toninho line of work~\citep{caires2010session,caires2016linear} established deep connections between linear logic and session types; GLP achieves similar resource-discipline properties through syntactic restrictions rather than type systems.

\mypara{Grassroots platforms}
The mathematical foundations for grassroots platforms were established in~\citep{shapiro2023grassrootsBA}, with atomic transactions introduced in~\citep{shapiro2025atomic}. Grassroots social networks~\citep{shapiro2023gsn}, cryptocurrencies~\citep{shapiro2024gc,lewis2023grassroots}, and federations~\citep{halpern2024federated,shapiro2025GF} have been formally specified and proven grassroots. GLP provides the programming language to implement these specifications.

\mypara{Companion papers}
This paper is part of a series on GLP. A companion paper~\citep{shapiro2026types} develops moded types for GLP, extending LP types~\citep{fruhwirth1991lics} with modes that capture directionality of communication, enabling typing of interactive partial computations. Another companion paper~\citep{shapiro2026implementing} provides implementation-ready operational semantics for both single-agent and multiagent GLP, proves their correctness with respect to the abstract definitions presented here, and provides an independent proof that the implementation is grassroots.
