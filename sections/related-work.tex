\section{Related Work}\label{section:related-work}

Grassroots platforms require agents to verify cryptographic identity and protocol compatibility upon contact, form authenticated channels, and coalesce spontaneously without global coordination. The language must support multiple concurrent platform instances and metaprogramming for tooling development. We examine how existing systems address these requirements.

\mypara{Concurrent Logic Programming}
GLP belongs to the family of concurrent logic programming (CLP) languages that emerged in the 1980s: Concurrent Prolog~\cite{shapiro1983subset}, GHC~\cite{ueda1986guarded}, and PARLOG~\cite{clark1986parlog}. These languages interpret goals as concurrent processes communicating through shared logical variables, using committed-choice execution with guarded clauses. Shapiro's comprehensive survey~\cite{shapiro1989family} documents this family and its design space.

A key evolution was \emph{flattening}: restricting guards to primitive tests only. Flat Concurrent Prolog (FCP)~\cite{mierowsky1985fcp} and Flat GHC~\cite{ueda1986guarded} demonstrated that flat guards suffice for practical parallel programming while dramatically simplifying semantics and implementation.

GLP can be understood as \textbf{Flat Concurrent Prolog with the Single-Reader Single-Writer (SRSW) constraint}. FCP introduced read-only annotations (\verb|?|) distinguishing readers from writers of shared variables, enabling dataflow synchronization. However, read-only unification proved semantically problematic: Levi and Palamidessi~\cite{levi1985readonly} showed it is order-dependent, and Mierowsky et al.~\cite{mierowsky1985fcp} documented non-modularity issues. GHC dispensed with read-only annotations entirely, relying on guard suspension semantics.

GLP's SRSW constraint---requiring that each variable has exactly one writer and one reader occurrence---resolves these difficulties by ensuring that (1) no races occur on variable binding, and (2) term matching suffices, eschewing unification entirely. The result is a cleaner semantic foundation while preserving the expressiveness of stream-based concurrent programming. GLP retains logic programming's metaprogramming capabilities~\cite{safra1988meta,lichtenstein1988concurrent,shapiro1984systems}, essential for platform tooling development.

\mypara{Modes in Concurrent Logic Programming}
Mode systems for CLP have a rich history. PARLOG used mode declarations at the predicate level, with input modes enforcing one-way matching. Ueda's work on moded Flat GHC~\cite{ueda1994moded,ueda1995io} is most directly relevant: his mode system assigns polarity to every variable occurrence (positive for input/read, negative for output/write), with the \emph{well-modedness} property guaranteeing each variable is written exactly once. Ueda's subsequent linearity analysis~\cite{ueda2001resource} identifies variables read exactly once, enabling compile-time garbage collection. GLP enforces both single-reader and single-writer universally as a syntactic restriction, whereas Ueda's system guarantees single-writer with single-reader as an optional refinement.

\mypara{Distributed actor and process languages}
Actor-based languages (Erlang/OTP~\cite{armstrong2013programming}, Akka~\cite{akka2022}, Pony~\cite{clebsch2015deny}) and active object languages~\cite{boer2017survey,boer2024active} provide message-passing concurrency and fault isolation. However, their security models operate at the transport layer (TLS in Akka Remote~\cite{akka2022}, Erlang's cookie-based authentication~\cite{armstrong2013programming}) rather than integrating cryptographic identity and code attestation into language primitives. Orleans~\cite{orleans2022} assumes trusted runtime environments, lacking the attestation mechanisms required for grassroots platforms where participants must verify code integrity without central coordination.

\mypara{Capability security}
E~\cite{miller2006robust} provides capability-based security through unforgeable object references with automatic encryption. While ensuring object uniqueness and access control, E does not address verifying real-world identity or protocol implementation attestation---distinct requirements for grassroots platforms.

\mypara{Linear logic and futures/promises}
GLP's SRSW constraint has deep connections to two foundational ideas. Girard's linear logic~\cite{girard1987linear} introduced the principle that resources must be used exactly once; GLP's single-writer/single-reader restriction enforces this at the variable level, ensuring each assignment is produced exactly once and consumed exactly once. Friedman and Wise's futures and promises~\cite{friedman1976impact} introduced placeholders for values computed asynchronously; GLP's reader/writer pairs realize this pattern, with the writer as promise (single producer) and reader as future (single consumer). The Caires-Pfenning-Toninho line of work~\cite{caires2010session,caires2016linear} established deep connections between linear logic and session types; GLP achieves similar resource-discipline properties through syntactic restrictions rather than type systems.

\mypara{Linear types and session types}
Linear types~\cite{wadler1990linear} ensure single-use of resources, similar to GLP's single-writer constraint. However, GLP's SRSW mechanism provides bidirectional pairing---each writer has exactly one reader---enabling authenticated channels without type-level tracking. Session types~\cite{honda1993types} specify communication protocols statically, with implementations in Links~\cite{cooper2007links,lindley2017lightweight}, Rust~\cite{jespersen2015session}, Scala~\cite{scalas2016lightweight}, and Go~\cite{castro2019distributed}. While these verify protocol conformance at compile time, GLP's reader/writer synchronization enforces protocol dynamically through suspension and resumption, and runtime attestation enables participants to verify protocol compatibility when establishing connections between independently-deployed agents.

\mypara{Concurrent coordination languages}
Concurrent ML~\cite{reppy1999concurrent} provides first-class synchronous channels and events. The Join Calculus~\cite{fournet1996reflexive} offers pattern-based synchronization through join patterns. GLP's SRSW variables provide asynchronous communication through reader/writer pairs with the monotonicity property (Proposition~\ref{prop:glp-monotonicity}) ensuring suspended goals remain reducible once readers are instantiated. However, neither provides mechanisms for cryptographic identity verification or authenticated channel establishment required for grassroots platforms.

\mypara{Blockchain programming languages}
Smart contract languages like Solidity~\cite{mukhopadhyay2018ethereum} and Move~\cite{move2022} provide deterministic execution and asset safety but assume blockchain infrastructure for identity and consensus. While Scilla~\cite{scilla2018} separates computation from communication similar to GLP's message-passing model, it targets on-chain state transitions rather than peer-to-peer authenticated channels. GLP achieves security properties through the language-level SRSW invariant and attestations, without requiring global consensus.

\mypara{Authorization languages}
OPA/Rego~\cite{opa2021} and Cedar~\cite{hicks2023cedar} provide declarative policy specification but are specialized for policy evaluation. They consume authentication tokens as inputs but do not integrate attestation as first-class primitives for verifying remote code execution.

\mypara{Grassroots platforms}
The mathematical foundations for grassroots platforms were established in~\cite{shapiro2023grassrootsBA}, with atomic transactions introduced in~\cite{shapiro2025atomic}. Grassroots social networks~\cite{shapiro2023gsn}, cryptocurrencies~\cite{shapiro2024gc,lewis2023grassroots}, and federations~\cite{halpern2024federated,shapiro2025GF} have been formally specified and proven grassroots. GLP provides the programming language to implement these specifications.
