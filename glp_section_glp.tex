%==============================================================================
\section{Grassroots Logic Programs}
\label{sec:glp}
%==============================================================================

Grassroots Logic Programs (GLP) extend LP by (1) adding a dual \emph{reader} $X?$ to every ``ordinary'' logic variable $X$, now called a \emph{writer} (2) restricting variables in goals and clauses to have at most a single occurrence (SO) (3) requiring that a variable occurs in a clause iff its dual variable also occurs in it (single-reader single-writer, SRSW). The result eschews unification in favour of simple term matching, is linear-logic-like, and is futures/promises-like: each assignment $X := T$ of a term $T$ to a variable $X$ is produced at most once, via the sole writer (promise) $X$, and consumed at most once, via its sole dual reader (future) $X?$.

The operational semantics of GLP extends that of LP as follows:
\begin{enumerate}
\item \textbf{Synchronisation}: Unification may only instantiate writers, so in addition to succeed/fail, unification may suspend if it requires instantiating readers.

\item \textbf{Communication}: When a unifying writer substitution binds a writer $X$ to a term $T$, the message  $X? := T$ encoding its dual reader assignment is created and added to the configuration. Its application happens asynchronously, realizing a message $T$ from the single occurrence of $X$ to the single occurrence of $X?$. 

\item \textbf{Deterministic clause selection}: The first applicable clause is chosen, not nondeterministically as in LP. This provides for the fairness of \verb|merge| presented below:  As long as the two input streams are available the output dovetails the two inputs, due to switching their order in the recursive call of the first clause; as long as only one stream is available, its elements are copied to the output; and when both streams are unavailable the goal suspends.
\end{enumerate}

The remainder of this section presents GLP syntax, operational semantics, and safety properties. A deterministic implementation-ready transition-system specification for GLP (irGLP) is presented in Appendix~\ref{appendix:irGLP}.

\subsection{GLP Variables: Readers and Writers}
\label{sec:glp-variables}

\begin{definition}[GLP Variables]
\label{def:glp-variables}
Recall that $\calV$ is the set of LP variables, henceforth called \temph{writers}. Define $\calV? = \{X? \mid X \in \calV\}$, called \temph{readers}. The set of all GLP variables is $\hat\calV = \calV \cup \calV?$. A writer $X$ and its reader $X?$ form a \temph{variable pair}. 
\end{definition}

GLP terms, goals, and clauses are as in LP except that they are defined over the variables in $\hat\calV$.  We use $\calG_?(P)$ to denote the set of goals over $\hat\calV$ restricted to the vocabulary of $P$.

\begin{definition}[Single-Occurrence (SO) Invariant, Single-Reader/Single-Writer (SRSW) Restriction]
\label{def:so-srsw}
A goal or clause satisfies the \temph{single-occurrence (SO) invariant} if every variable occurs in it at most once.  A clause $C$ satisfies the \temph{single-reader/single-writer (SRSW) syntactic restriction} if it satisfies SO and, furthermore, a variable occurs in $C$ iff its dual variable also occurs in $C$. 
\end{definition}

As we shall see (Proposition~\ref{prop:so-preservation}), the SO invariant is maintained by the SRSW restriction: reducing a goal satisfying SO with a clause satisfying SRSW results in a goal satisfying SO.  The goal of the SRSW requirement is to prevent multiple writer occurrences racing to bind a variable.  However, the type of a variable may be determined to be ground by guards (e.g.\ \verb|ground(X)|), and hence may not include writers, now or in the future. In such a case the requirement is relaxed and any number of readers in a clause are allowed.

\mypara{No writer-to-writer binding (WxW)}
In addition, GLP requires \emph{no writer-to-writer} binding (WxW).  A reader/writer pair $X?/X$ is a communication channel from the writer $X$ to the reader $X?$.
If two writers $X$ and $Y$ are unified during execution, the SRSW requirement implies that no occurrences of either $X$ or $Y$ are left to instantiate them, and therefore their dual readers $X?$ and $Y?$ will be left \emph{abandoned}.  Combined, the WxW and SRSW restrictions ensure that communication channels are properly closed, with no reader left abandoned by its dual writer.

\begin{remark}[Anonymous Variables]
\label{rem:anonymous-variables}
The \temph{anonymous variable} \verb|_| in GLP programs may appear anywhere a writer variable may appear.  Each occurrence denotes a fresh writer with no dual reader, providing a controlled exception to the SRSW restriction.  Values assigned to \verb|_| are discarded.  For example:
\begin{verbatim}
second([_, X | _], X?).
foo(X) :- bar(_, X?).
\end{verbatim}
In the first clause, \verb|_| discards the head and tail of the input list.  In the second, \verb|_| discards the first output of \verb|bar|.
\end{remark}

\begin{example}[Merge]
Consider the quintessential concurrent logic program for fairly merging two streams, written in GLP:
\begin{verbatim}
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge(Xs, [], Xs?).
merge([], Ys, Ys?).
\end{verbatim}
and the goal \verb=merge([1,2,3|Xs?],[a,b|Ys?],Zs)=.
Note that both satisfy SO and each clause satisfies SRSW.
\end{example}

%------------------------------------------------------------------------------
\subsection{Operational Semantics}
\label{sec:glp-operational}
%------------------------------------------------------------------------------


\begin{definition}[Writers Substitution, Assignment, Readers Substitution and Counterpart]
\label{def:writers-assignment}
A GLP \temph{writer assignment} is a term of the form $X := T$,  $X\in\calV$,  $T\notin\calV$,
satisfying SO. 
Similarly, a GLP \temph{reader assignment} is a term of the form $X? := T$,  $X?\in\calV?$,  $T\notin\calV$,
satisfying SO. 
A \temph{writers (readers) substitution} $\sigma$ is the substitution implied by a set of writer (reader) assignments that jointly satisfy SO. Given a writers assignment $X := T$, its \temph{readers counterpart} is $X? := T$, and given a writers substitution $\sigma$, its \temph{readers counterpart} $\sigma?$ is the readers substitution defined by $X?\sigma? = X\sigma$. 
\end{definition}


\begin{definition}[GLP Renaming, Renaming Apart]
\label{def:glp-renaming}
A \temph{GLP renaming} is a substitution $\rho: \hat\calV \to \hat\calV$ such that for each $X \in \calV$: $X\rho \in \calV$ and $X?\rho = (X\rho)?$. 
Two GLP terms have a variable in common if for some writer $X \in \calV$, either $X$ or $X?$ occurs in both. A GLP renaming $\sigma$ renames $T'$ \temph{apart from} $T$ if $T'\sigma$ and $T$  have no variable in common.
\end{definition}


\begin{definition}[GLP Goal/Clause Reduction]\label{def:glp-reduction}
Given GLP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of the GLP renaming of $C$ apart from $A$, the \temph{GLP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$ if $A$ and $H$ have a writer mgu.
\end{definition}



\begin{definition}[GLP Transition System]
\label{def:glp-ts}
Given a GLP program $P$, an \temph{asynchronous resolvent} over $P$ is a pair $(G, \sigma)$ where $G \in \calG_?(P)$ and $\sigma$ is a readers substitution.

A transition system $GLP = (\calC, c_0, \calT)$ is a \temph{GLP transition system} over $P$ and initial goal $G_0$ satisfying SO if:
\begin{enumerate}
    \item $\calC$ is the set of all asynchronous resolvents over $P$
    \item $c_0 = (G_0, \emptyset)$
    \item $\calT$ is the set of all transitions $(G, \sigma) \rightarrow (G', \sigma')$ satisfying either:
    \begin{enumerate}
        \item \textbf{Reduce:} there exists unit goal $A \in G$ such that $C \in P$ is the first clause for which the GLP reduction of $A$ with $C$ succeeds with result $(B, \hat\sigma)$, $G' = (G \setminus \{A\} \cup B)\hat\sigma$, and $\sigma' = \sigma \circ \hat\sigma?$
        \item \textbf{Communicate:} $\hat\sigma = \{X := T\} \in \sigma$, $X?\in G$,
        $G' = G\hat\sigma?$, and $\sigma' = \sigma$
    \end{enumerate}
\end{enumerate}
\end{definition}

GLP Reduce is different from LP in (1) the use of a writer mgu instead of a regular mgu and (2) the choice of the first applicable clause instead of any clause.  The first is the fundamental use of GLP readers for synchronization. The second compromises on the or-nondeterminism of LP to allow the writing of fair concurrent programs, such as fair merge above.  Note that or-nondeterminism is not completely eliminated, as different scheduling of arrival of bindings on the two input streams of \verb|merge| may result in different orders in its output stream.
The GLP Communicate rule realises the use of reader/writer pairs for asynchronous communication:  It applies an assignment to a reader after it has been applied to its dual writer.

Abstractly, the key differences between LP and GLP relate to monotonicity:  In LP, if a goal cannot be reduced, it will never be reduced. In GLP, a goal that cannot be reduced now may be reduced in the future, due to GLP's use of dual logic variables for communication and synchronization:  If $A$ and $H$ have an mgu that writes on a reader $X? \in A$, and therefore have no writer mgu at present, it may be possible that another goal that has $X$ will reduce, assigning $X$, and later $X?$, to a value that will allow $A$ and $H$ to have a writer mgu.  Conversely, in LP, if a goal $A$ can be reduced now with some clause $H:-B$, with a regular mgu of $A$ and $H$, it may not be reducible in the future due to variables that $A$ shares with other goals being assigned values by other goal reductions, preventing unification between the instantiated $A$ and $H$.  In GLP, if a goal $A$ can be reduced now (with a writers mgu), it can always be reduced in the future, as the SO invariant ensures that no other goal can assign any writer in $A$.

Implementation-wise, if a GLP goal $A$ cannot be reduced now, but there is a readers substitution $\sigma$ such that $A\sigma$ can be reduced, such readers are identified, the goal $A$ \emph{suspends} on these readers, and is rescheduled for reduction once any of them is assigned.

Despite these differences, GLP can adopt the same notion of successful run and outcome of LP (Definition \ref{def:proper-run}), and have the same notion of logic consequence as LP.  Let $/?$ be an operator that replaces every reader by its dual writer.

\mypara{Guards and system predicates}
GLP also includes \emph{guards}---predicates that test runtime conditions (e.g., \verb|ground(X)| tests if \verb|X| contains no variables) without modifying state, appearing after clause heads separated by \verb=|=---and \emph{system predicates} that provide access to the GLP runtime state and operating system and hardware capabilities (variable state and name, arithmetic evaluation, timestamps). Guards enable conditional clause selection. The \verb|ground(X)| guard allows relaxing the single-reader constraint for \verb|X?| for the clause it occurs in, as having multiple occurrences of \verb|X?| instantiated to a ground term does not violate the fundamental single-writer requirement.
Their specification appears in Appendix~\ref{appendix:guards-system}.


\subsection{Term Matching Eschews Unification}

If two terms $T_1$ and $T_2$ that jointly satisfy SO are unifiable with an mgu $\sigma$, then $\sigma$ maps any variable in $T_1$ to a subterm of $T_2$ and vice versa.  Hence, the SO invariant of GLP allows eschewing unification in favour of \emph{term matching}  that performs joint term-tree traversal and collects variable assignments along the way, as follows.

\begin{definition}[Term Matching]
\label{def:term-matching}
Given two terms $T_1$ and $T_2$ that jointly satisfy SO, their \temph{term matching} proceeds via the joint traversal of the term-trees of $T_1$ and $T_2$, consulting the following table at each pair of joint vertices, where $X_1, X_2$ denote writers, $X_1?, X_2?$ denote readers, and $f/n$ denotes a non-variable term,  a constant (strings, numbers, functors/predicate names) when $n=0$ and a compound term when $n>0$:
\begin{center}
\begin{tabular}{l|lll}
$T_1 \backslash T_2$ & Writer $X_2$ & Reader $X_2?$ & Term $f_2/n_2$ \\
\hline
Writer $X_1$ & fail & $X_1 := X_2?$ & $X_1 := T_2$ \\
Reader $X_1?$ & $X_2 := X_1?$ & fail &  suspend on $X_1?$\\
Term $f_1/n_2$ & $X_2 := T_1$ &  fail & fail if $f_1\ne f_2$ or $n_1\ne n_2$\\
\end{tabular}
\end{center}
The writer mgu is the union of all writer assignments if no \emph{fail} was encountered and the suspension set is empty.
\end{definition}

%------------------------------------------------------------------------------
\subsection{GLP Safety Properties}
\label{sec:glp-safety}
%------------------------------------------------------------------------------

Here we prove that, like LP, GLP computations are deductions, but, unlike LP, a goal that can be reduced in a configuration can still be reduced in any subsequent configuration of the computation.

\begin{proposition}[GLP Computation is Deduction]
\label{prop:glp-deduction}
Let  $(G_0$ \verb|:-| $G_n)\sigma$ be the outcome of a proper  run $\rho: (G_0,\sigma_0) \rightarrow  \cdots \rightarrow (G_n, \sigma_n)$ of $GLP(P)$.
Then $(G_0$ \verb|:-| $G_n)\sigma/?$ is a logical consequence of $P/?$.
\end{proposition}

\begin{proof}
The $/\!?$ operator replaces every reader $X?$ by its dual writer $X$, transforming GLP terms into LP terms.  We show that the GLP run $\rho$ corresponds to an LP run $\rho/?$ of $LP(P/?)$.

Consider a GLP transition $(G, \sigma) \rightarrow (G', \sigma')$:
\begin{itemize}
    \item \emph{Reduce transition}: Goal $A$ reduces with clause $C$ via writer mgu $\hat\sigma$.  Applying $/\!?$, the clause $C/?$ is an LP clause, and $A/?$ unifies with the head $H/?$ via the mgu $\hat\sigma/?$ (since writers map to writers).  This is a valid LP reduction.
    \item \emph{Communicate transition}: A reader $X? \in G$ is replaced by the value $T$ assigned to its dual writer.  Under $/\!?$, both $X?$ and $X$ map to $X$, so this transition becomes the identity---the variable $X$ is already bound to $T$ in the LP view.
\end{itemize}

Thus each GLP transition corresponds to zero or one LP transitions, and the GLP run $\rho$ projects to an LP run $\rho/?$ of $LP(P/?)$.  By Proposition~\ref{prop:lp-deduction}, the outcome of $\rho/?$ is a logical consequence of $P/?$.
\end{proof}

We note additional safety properties of GLP runs.

\begin{proposition}[SO Preservation]
\label{prop:so-preservation}
If the initial goal $G_0$ satisfies SO, then every goal in the GLP run satisfies SO.
\end{proposition}

\begin{proof}
By induction on the length of the run.  The base case is immediate: $G_0$ satisfies SO by assumption.

For the inductive step, assume $G$ satisfies SO and consider a transition $(G, \sigma) \rightarrow (G', \sigma')$:
\begin{itemize}
    \item \emph{Reduce transition}: Goal $A \in G$ reduces with clause $C = (H \mathrel{\mbox{\texttt{:-}}} B)$ via writer mgu $\hat\sigma$, yielding $G' = (G \setminus \{A\} \cup B)\hat\sigma$.  Since $C$ satisfies SRSW, it satisfies SO.  Since $C$ is renamed apart from $G$, the variables in $B$ are fresh.  The writer mgu $\hat\sigma$ maps writers in $A$ to subterms of $H$ and vice versa; by SO of both $G$ and $C$, each variable is assigned at most once.  Applying $\hat\sigma$ to $(G \setminus \{A\} \cup B)$ replaces each variable by a term containing fresh variables (from $B$) or ground subterms.  Since no variable in $G \setminus \{A\}$ occurs in $A$ (by SO of $G$), and no variable in $B$ occurs in $G$ (by renaming apart), $G'$ satisfies SO.
    
    \item \emph{Communicate transition}: $G' = G\hat\sigma?$ where $\hat\sigma? = \{X? := T\}$.  Since $G$ satisfies SO, $X?$ occurs at most once in $G$.  Replacing this single occurrence by $T$ (which satisfies SO by Definition~\ref{def:writers-assignment}) preserves SO, provided $T$ shares no variables with the rest of $G$.  By the proper run condition (Definition~\ref{def:proper-run}), variables in $T$ are fresh, so $G'$ satisfies SO.
\end{itemize}
\end{proof}

\begin{proposition}[Acyclicity]
\label{prop:acyclicity}
If the initial goal $G_0$ in a GLP run contains no circular terms, then no goal in the run contains a circular term.
\end{proposition}

\begin{proof}
A circular term would require a writer $X$ to be bound to a term containing its dual reader $X?$. The writer mgu construction (Definition~\ref{def:term-matching}) only produces assignments of the form $X := T$ where $T$ is a subterm of the clause head. Since clauses satisfy SRSW, if $X$ appears in a clause then $X?$ also appears, but in a different position. The renaming-apart ensures fresh variables, so no assignment $X := T$ can have $X?$ occurring in $T$.
\end{proof}

\begin{proposition}[Monotonicity]
\label{prop:glp-monotonicity}
In any GLP run, if unit goal $A$ can reduce with clause $C$ at step $i$, then either an instance of $A$ has been reduced by step $j > i$, or an instance of $A$ can still reduce with $C$ at step $j$.
\end{proposition}

\begin{proof}
Suppose goal $A$ can reduce with clause $C$ at step $i$, meaning the writer mgu of $A$ and the head $H$ of (a renaming of) $C$ succeeds.  Consider what can change between steps $i$ and $j > i$:
\begin{itemize}
    \item \emph{Reduce transitions on other goals}: These do not affect $A$ directly.  By SO, no other goal shares a writer with $A$, so no other reduction can bind a writer in $A$.
    
    \item \emph{Communicate transitions}: These bind readers, not writers.  A communicate transition $X? := T$ may instantiate a reader $X? \in A$, yielding $A' = A\{X? := T\}$.  We show $A'$ can still reduce with $C$:
    
    The original writer mgu succeeded, meaning at position $p$ where $X?$ occurred in $A$, either (a) $H$ had a writer $Y$ at position $p$, yielding assignment $Y := X?$, or (b) $H$ had a reader $Y?$ at position $p$, which would have caused failure (reader-reader), contradiction.
    
    In case (a), after the communicate transition, $A'$ has $T$ at position $p$.  The clause $C$ (renamed apart for $A'$) has a fresh writer $Y'$ at position $p$.  The writer mgu now yields $Y' := T$, which succeeds.
    
    \item \emph{Reduce transition on $A$}: If $A$ itself is reduced at some step $k$ with $i < k \le j$, then an instance of $A$ has been reduced, satisfying the proposition.
\end{itemize}

Thus, if $A$ has not been reduced by step $j$, the (possibly instantiated) goal $A'$ at step $j$ can still reduce with a fresh renaming of $C$.
\end{proof}
