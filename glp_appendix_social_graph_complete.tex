%==============================================================================
\section{Complete Social Graph Program}
\label{appendix:social-graph-complete}
%==============================================================================

This appendix presents the complete GLP social graph program that demonstrates cold-call befriending, text messaging, and friend-mediated introduction. The program includes three agents (Alice, Bob, Charlie) driven by actor scripts that execute a comprehensive scenario.

%------------------------------------------------------------------------------
\subsection{The Scenario}
\label{app:scenario}
%------------------------------------------------------------------------------

The play executes the following sequence:
\begin{enumerate}
\item Alice cold-calls Bob (Bob accepts) --- Alice and Bob become friends
\item Alice sends message to Bob: ``Hi Bob, this is Alice''
\item Bob cold-calls Charlie (Charlie accepts) --- Bob and Charlie become friends
\item Charlie sends message to Bob: ``Hi Bob, this is Charlie''
\item Bob introduces Alice to Charlie (both accept) --- Alice and Charlie become direct friends
\item Alice sends message to Charlie: ``Hi Charlie, this is Alice''
\item Charlie responds to Alice: ``Hi Alice, this is Charlie''
\end{enumerate}

%------------------------------------------------------------------------------
\subsection{Type Definitions}
\label{app:types}
%------------------------------------------------------------------------------

\begin{verbatim}
Response ::= accept(Channel) ; no.
FriendEntry ::= friend(String?, Stream).
FriendsList ::= [] ; [FriendEntry|FriendsList].
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Channel Operations}
\label{app:channel-ops}
%------------------------------------------------------------------------------

\begin{verbatim}
%% send(Msg, ChIn, ChOut) - send message on channel
send(X, ch(In, [X?|Out?]), ch(In?, Out)).

%% receive(Msg, ChIn, ChOut) - receive message from channel
receive(X?, ch([X|In], Out?), ch(In?, Out)).

%% new_channel(Ch1, Ch2) - create connected channel pair
new_channel(ch(Xs?, Ys), ch(Ys?, Xs)).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Stream Utilities}
\label{app:stream-utils}
%------------------------------------------------------------------------------

\begin{verbatim}
procedure merge(Stream?, Stream?, Stream).
merge([X|Xs], Ys, [X?|Zs?]) :- merge(Ys?, Xs?, Zs).
merge(Xs, [Y|Ys], [Y?|Zs?]) :- merge(Xs?, Ys?, Zs).
merge([], Ys, Ys?).
merge(Xs, [], Xs?).

procedure tag_stream(_?, Stream?, Stream).
tag_stream(Name, [M|In], [msg(Name?, Name?, M?)|Out?]) :-
    ground(Name?) | tag_stream(Name?, In?, Out).
tag_stream(_, [], []).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Friends List Operations}
\label{app:friends-ops}
%------------------------------------------------------------------------------

\begin{verbatim}
procedure lookup_send(String?, _?, FriendsList?, FriendsList).
lookup_send(Key, Msg, Fs, Fs1?) :-
    ground(Key?) |
    lookup_send_step(Key?, Msg?, Fs?, Fs1).

procedure lookup_send_step(String?, _?, FriendsList?, FriendsList).
lookup_send_step(Key, Msg, [friend(K, [Msg?|Out1?])|Rest], [friend(K?, Out1)|Rest?]) :-
    Key? =?= K? | true.
lookup_send_step(Key, Msg, [friend(K, Out?)|Rest], [friend(K?, Out)|Rest1?]) :-
    otherwise |
    lookup_send_step(Key?, Msg?, Rest?, Rest1).
lookup_send_step(_, _, [], []).

procedure inject_msg(Response?, _?, _?, Stream?, Stream).
inject_msg(Resp, Target, Id, Ys, [msg(Target?, Id?, response(Resp?))|Ys?]) :-
    known(Resp?) | true.
inject_msg(Resp, Target, Id, [Y|Ys], [Y?|Ys1?]) :-
    otherwise | inject_msg(Resp?, Target?, Id?, Ys?, Ys1).

procedure add_friend(_?, Stream, FriendsList?, FriendsList).
add_friend(Name, Out?, Fs, [friend(Name?, Out)|Fs?]).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Response Handling}
\label{app:response-handling}
%------------------------------------------------------------------------------

\begin{verbatim}
procedure bind_response(_?, _?, Response, FriendsList?, FriendsList, Stream?, Stream).
bind_response(yes, From, accept(RetCh?), Fs, Fs1?, In, In1?) :-
    new_channel(RetCh, LocalCh) |
    handle_response(accept(LocalCh?), From?, Fs?, Fs1, In?, In1).
bind_response(no, _, no, Fs, Fs?, In, In?).

procedure handle_response(Response?, _?, FriendsList?, FriendsList, Stream?, Stream).
handle_response(accept(ch(FIn, FOut?)), From, Fs, Fs1?, In, In1?) :-
    ground(From?) |
    merge(In?, FIn?, In1),
    add_friend_and_notify(From?, FOut, Fs?, Fs1).
handle_response(no, From, Fs, Fs1?, In, In?) :-
    ground(From?) |
    lookup_send(user, msg(agent, user, rejected(From?)), Fs?, Fs1).

procedure add_friend_and_notify(_?, Stream, FriendsList?, FriendsList).
add_friend_and_notify(From, FOut?, Fs, [friend(From?, FOut)|Fs1?]) :-
    ground(From?) |
    lookup_send(user, msg(agent, user, connected(From?)), Fs?, Fs1).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{The Agent}
\label{app:agent}
%------------------------------------------------------------------------------

The agent procedure is the main event loop handling all protocols.

\begin{verbatim}
procedure agent(_?, Stream?, FriendsList?).

%% --- Cold-call protocol ---

%% User initiates cold call
agent(Id, [msg(user, Id1, connect(Target))|In], Fs) :-
    ground(Id?), ground(Target?), Id? =?= Id1? |
    lookup_send(net, msg(Id?, Target?, intro(Id?, Id?, Resp)), Fs?, Fs1),
    inject_msg(Resp?, Target?, Id?, In?, In1),
    agent(Id?, In1?, Fs1?).

%% Received self-introduction (cold-call: 3-arg intro) - forward to user
agent(Id, [msg(From, Id1, intro(From1, From2, Resp))|In], Fs) :-
    ground(Id?), ground(From?), Id? =?= Id1?, From? =?= From1?, From? =?= From2? |
    lookup_send(user, msg(agent, user, befriend(From?, Resp?)), Fs?, Fs1),
    agent(Id?, In?, Fs1?).

%% User decision on cold-call introduction
agent(Id, [msg(user, Id1, decision(Dec, From, Resp?))|In], Fs) :-
    ground(Id?), Id? =?= Id1? |
    bind_response(Dec?, From?, Resp, Fs?, Fs1, In?, In1),
    agent(Id?, In1?, Fs1?).

%% Response to sent cold-call introduction
agent(Id, [msg(From, Id1, response(Resp))|In], Fs) :-
    ground(Id?), ground(From?), Id? =?= Id1? |
    handle_response(Resp?, From?, Fs?, Fs1, In?, In1),
    agent(Id?, In1?, Fs1?).

%% --- Text messaging ---

%% User sends text message to friend
agent(Id, [msg(user, Id1, send(Target, Text))|In], Fs) :-
    ground(Id?), ground(Target?), Id? =?= Id1? |
    lookup_send(Target?, msg(Id?, Target?, text(Text?)), Fs?, Fs1),
    agent(Id?, In?, Fs1?).

%% Received text message from friend - forward to user
agent(Id, [msg(From, Id1, text(Text))|In], Fs) :-
    ground(Id?), ground(From?), Id? =?= Id1? |
    lookup_send(user, msg(agent, user, received(From?, Text?)), Fs?, Fs1),
    agent(Id?, In?, Fs1?).

%% --- Friend-mediated introduction protocol ---

%% User commands: introduce P to Q (creates bidirectional channel)
agent(Id, [msg(user, Id1, introduce(P, Q))|In], Fs) :-
    ground(Id?), ground(P?), ground(Q?), Id? =?= Id1?, new_channel(PQCh, QPCh) |
    lookup_send(P?, msg(Id?, P?, intro(Q?, QPCh?)), Fs?, Fs1),
    lookup_send(Q?, msg(Id?, Q?, intro(P?, PQCh?)), Fs1?, Fs2),
    agent(Id?, In?, Fs2?).

%% Received introduction from friend (2-arg intro) - forward to user
agent(Id, [msg(From, Id1, intro(Other, Ch))|In], Fs) :-
    ground(Id?), ground(From?), ground(Other?), Id? =?= Id1? |
    lookup_send(user, msg(agent, user, befriend_intro(From?, Other?, Ch?)), Fs?, Fs1),
    agent(Id?, In?, Fs1?).

%% User accepts friend introduction
agent(Id, [msg(user, Id1, accept_intro(Other, Ch))|In], Fs) :-
    ground(Id?), ground(Other?), Id? =?= Id1? |
    handle_intro_accept(Ch?, Other?, Fs?, Fs1, In?, In1),
    agent(Id?, In1?, Fs1?).

%% User rejects friend introduction
agent(Id, [msg(user, Id1, reject_intro(_))|In], Fs) :-
    ground(Id?), Id? =?= Id1? |
    agent(Id?, In?, Fs?).

%% --- Catch-all and termination ---

agent(Id, [_|In], Fs) :-
    ground(Id?), otherwise |
    agent(Id?, In?, Fs?).

agent(_, [], _).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Introduction Acceptance}
\label{app:intro-accept}
%------------------------------------------------------------------------------

\begin{verbatim}
procedure handle_intro_accept(Channel?, _?, FriendsList?, FriendsList, Stream?, Stream).
handle_intro_accept(ch(FIn, FOut?), Other, Fs, Fs1?, In, In1?) :-
    ground(Other?) |
    add_friend(Other?, FOut, Fs?, Fs1),
    merge(In?, FIn?, In1).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Agent Initialization}
\label{app:agent-init}
%------------------------------------------------------------------------------

\begin{verbatim}
procedure agent_init(_?, Channel?, Channel?).
agent_init(Id, ch(UserIn, UserOut?), ch(NetIn, NetOut?)) :-
    merge(UserIn?, NetIn?, In),
    agent(Id?, In?, [friend(user, UserOut), friend(net, NetOut)]).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Network Switch}
\label{app:network-switch}
%------------------------------------------------------------------------------

The three-way network switch routes messages between Alice, Bob, and Charlie.

\begin{verbatim}
procedure network3(Channel?, Channel?, Channel?).

%% Alice -> Bob
network3(ch([msg(alice, bob, X)|AliceIn], AliceOut?),
         ch(BobIn, [msg(alice, bob, X?)|BobOut?]),
         ch(CharlieIn, CharlieOut?)) :-
    network3(ch(AliceIn?, AliceOut), ch(BobIn?, BobOut), ch(CharlieIn?, CharlieOut)).

%% Alice -> Charlie
network3(ch([msg(alice, charlie, X)|AliceIn], AliceOut?),
         ch(BobIn, BobOut?),
         ch(CharlieIn, [msg(alice, charlie, X?)|CharlieOut?])) :-
    network3(ch(AliceIn?, AliceOut), ch(BobIn?, BobOut), ch(CharlieIn?, CharlieOut)).

%% Bob -> Alice
network3(ch(AliceIn, [msg(bob, alice, X?)|AliceOut?]),
         ch([msg(bob, alice, X)|BobIn], BobOut?),
         ch(CharlieIn, CharlieOut?)) :-
    network3(ch(AliceIn?, AliceOut), ch(BobIn?, BobOut), ch(CharlieIn?, CharlieOut)).

%% Bob -> Charlie
network3(ch(AliceIn, AliceOut?),
         ch([msg(bob, charlie, X)|BobIn], BobOut?),
         ch(CharlieIn, [msg(bob, charlie, X?)|CharlieOut?])) :-
    network3(ch(AliceIn?, AliceOut), ch(BobIn?, BobOut), ch(CharlieIn?, CharlieOut)).

%% Charlie -> Alice
network3(ch(AliceIn, [msg(charlie, alice, X?)|AliceOut?]),
         ch(BobIn, BobOut?),
         ch([msg(charlie, alice, X)|CharlieIn], CharlieOut?)) :-
    network3(ch(AliceIn?, AliceOut), ch(BobIn?, BobOut), ch(CharlieIn?, CharlieOut)).

%% Charlie -> Bob
network3(ch(AliceIn, AliceOut?),
         ch(BobIn, [msg(charlie, bob, X?)|BobOut?]),
         ch([msg(charlie, bob, X)|CharlieIn], CharlieOut?)) :-
    network3(ch(AliceIn?, AliceOut), ch(BobIn?, BobOut), ch(CharlieIn?, CharlieOut)).

%% Termination
network3(ch([], []), ch([], []), ch([], [])).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{Actors as State Machines}
\label{app:actors}
%------------------------------------------------------------------------------

Each actor is a GLP procedure that implements a state machine, reacting to messages from the agent and producing commands for it. The actor's state is encoded in the procedure name (e.g., \verb|alice_wait_bob_connected|, \verb|alice_wait_intro|), and transitions occur via recursive calls to different procedures.

\subsubsection{Alice's Actor}

Alice's script: (1) cold-call Bob, (2) wait for connection confirmation, (3) send greeting to Bob, (4) wait for introduction to Charlie and accept it, (5) send greeting to Charlie, (6) wait for Charlie's reply, (7) drain remaining messages.

\begin{verbatim}
procedure alice_actor(Channel?).
alice_actor(ch(In, [msg(user, alice, connect(bob))|Out?])) :-
    alice_wait_bob_connected(In?, Out).

procedure alice_wait_bob_connected(Stream?, Stream).
alice_wait_bob_connected([msg(agent, user, connected(bob))|In],
                         [msg(user, alice, send(bob, 'Hi Bob, this is Alice'))|Out?]) :-
    alice_wait_intro(In?, Out).
alice_wait_bob_connected([], []).

procedure alice_wait_intro(Stream?, Stream).
alice_wait_intro([msg(agent, user, connected(_))|In], Out?) :-
    alice_wait_intro(In?, Out).
alice_wait_intro([msg(agent, user, received(_, _))|In], Out?) :-
    alice_wait_intro(In?, Out).
alice_wait_intro([msg(agent, user, befriend_intro(_, Other, Ch))|In],
                 [msg(user, alice, accept_intro(Other?, Ch?))|Out?]) :-
    ground(Other?) |
    alice_send_to_charlie(In?, Out).
alice_wait_intro([], []).

procedure alice_send_to_charlie(Stream?, Stream).
alice_send_to_charlie(In, [msg(user, alice, send(charlie, 'Hi Charlie, this is Alice'))|Out?]) :-
    alice_wait_charlie_reply(In?, Out).

procedure alice_wait_charlie_reply(Stream?, Stream).
alice_wait_charlie_reply([msg(agent, user, received(charlie, _))|In], Out?) :-
    alice_drain(In?, Out).
alice_wait_charlie_reply([msg(agent, user, connected(_))|In], Out?) :-
    alice_wait_charlie_reply(In?, Out).
alice_wait_charlie_reply([], []).

procedure alice_drain(Stream?, Stream).
alice_drain([_|In], Out?) :- alice_drain(In?, Out).
alice_drain([], []).
\end{verbatim}

\subsubsection{Bob's Actor}

Bob's script: (1) accept Alice's cold-call, (2) receive Alice's message, (3) cold-call Charlie, (4) wait for connection, (5) receive Charlie's message, (6) introduce Alice to Charlie, (7) drain.

\begin{verbatim}
procedure bob_actor(Channel?).
bob_actor(ch([msg(agent, user, befriend(From, Resp))|In],
             [msg(user, bob, decision(yes, From?, Resp?))|Out?])) :-
    ground(From?) |
    bob_wait_alice_msg(In?, Out).

procedure bob_wait_alice_msg(Stream?, Stream).
bob_wait_alice_msg([msg(agent, user, connected(_))|In], Out?) :-
    bob_wait_alice_msg(In?, Out).
bob_wait_alice_msg([msg(agent, user, received(alice, _))|In],
                   [msg(user, bob, connect(charlie))|Out?]) :-
    bob_wait_charlie_connected(In?, Out).
bob_wait_alice_msg([], []).

procedure bob_wait_charlie_connected(Stream?, Stream).
bob_wait_charlie_connected([msg(agent, user, connected(charlie))|In], Out?) :-
    bob_wait_charlie_msg(In?, Out).
bob_wait_charlie_connected([msg(agent, user, connected(_))|In], Out?) :-
    bob_wait_charlie_connected(In?, Out).
bob_wait_charlie_connected([], []).

procedure bob_wait_charlie_msg(Stream?, Stream).
bob_wait_charlie_msg([msg(agent, user, received(charlie, _))|In],
                     [msg(user, bob, introduce(alice, charlie))|Out?]) :-
    bob_drain(In?, Out).
bob_wait_charlie_msg([msg(agent, user, connected(_))|In], Out?) :-
    bob_wait_charlie_msg(In?, Out).
bob_wait_charlie_msg([], []).

procedure bob_drain(Stream?, Stream).
bob_drain([_|In], Out?) :- bob_drain(In?, Out).
bob_drain([], []).
\end{verbatim}

\subsubsection{Charlie's Actor}

Charlie's script: (1) accept Bob's cold-call, (2) send greeting to Bob, (3) wait for introduction to Alice and accept it, (4) receive Alice's message, (5) send reply to Alice, (6) drain.

\begin{verbatim}
procedure charlie_actor(Channel?).
charlie_actor(ch([msg(agent, user, befriend(From, Resp))|In],
                 [msg(user, charlie, decision(yes, From?, Resp?)),
                  msg(user, charlie, send(bob, 'Hi Bob, this is Charlie'))|Out?])) :-
    ground(From?) |
    charlie_wait_intro(In?, Out).

procedure charlie_wait_intro(Stream?, Stream).
charlie_wait_intro([msg(agent, user, connected(_))|In], Out?) :-
    charlie_wait_intro(In?, Out).
charlie_wait_intro([msg(agent, user, befriend_intro(_, Other, Ch))|In],
                   [msg(user, charlie, accept_intro(Other?, Ch?))|Out?]) :-
    ground(Other?) |
    charlie_wait_alice_msg(In?, Out).
charlie_wait_intro([], []).

procedure charlie_wait_alice_msg(Stream?, Stream).
charlie_wait_alice_msg([msg(agent, user, received(alice, _))|In],
                       [msg(user, charlie, send(alice, 'Hi Alice, this is Charlie'))|Out?]) :-
    charlie_drain(In?, Out).
charlie_wait_alice_msg([msg(agent, user, connected(_))|In], Out?) :-
    charlie_wait_alice_msg(In?, Out).
charlie_wait_alice_msg([], []).

procedure charlie_drain(Stream?, Stream).
charlie_drain([_|In], Out?) :- charlie_drain(In?, Out).
charlie_drain([], []).
\end{verbatim}

%------------------------------------------------------------------------------
\subsection{The Play}
\label{app:play}
%------------------------------------------------------------------------------

The play initializes three agents with their user and network channels, connects them via the network switch, and starts each actor.

\begin{verbatim}
procedure play_alice_bob_charlie.
play_alice_bob_charlie :-
    new_channel(AliceUserCh, UserAliceCh),
    new_channel(AliceNetCh, NetAliceCh),
    new_channel(BobUserCh, UserBobCh),
    new_channel(BobNetCh, NetBobCh),
    new_channel(CharlieUserCh, UserCharlieCh),
    new_channel(CharlieNetCh, NetCharlieCh),

    network3(NetAliceCh?, NetBobCh?, NetCharlieCh?),
    agent_init(alice, AliceUserCh?, AliceNetCh?),
    agent_init(bob, BobUserCh?, BobNetCh?),
    agent_init(charlie, CharlieUserCh?, CharlieNetCh?),
    alice_actor(UserAliceCh?),
    bob_actor(UserBobCh?),
    charlie_actor(UserCharlieCh?).
\end{verbatim}

The play terminates successfully when all streams are closed and all agents reach their terminal states.
