\section{Logic Programs}\label{section:lp}

Here we introduce transition systems, providing the formal framework for the operational semantics of both Logic Programs and GLP.
We recall standard Logic Programs (LP): syntax, most-general unifier (mgu), operational semantics via nondeterministic goal/clause reduction, compositional semantics, and a proof that LP computations are deductions. 


\subsection{Transition Systems}


We use $\subset$ to denote the strict subset relation, $\subseteq$ when equality is also possible, and $a\ne b \in S$ as a shorthand for $a\ne b\wedge a\in S \wedge b\in S$.
%
The following definition uses `configuration' rather than the more standard `state'  to avoid confusion with the `local state' of agents in a multiagent transition system, Definition~\ref{definition:mts}.

\begin{definition}[Transition System]\label{definition:ts}
A \temph{transition system} is a tuple $TS = (C, c0, T)$ where:
\begin{itemize}
    \item $C$ is an arbitrary set of \temph{configurations}
    \item $c0 \in C$ is a designated \temph{initial configuration}
    \item $T \subseteq C \times C$ is a \temph{transition relation}. A transition $(c,c') \in T$ is also written as $c \rightarrow c' \in T$.
\end{itemize}
A transition $c \rightarrow c' \in T$ is \temph{enabled} from configuration $c$. A configuration $c$ is \temph{terminal} if no transitions are enabled from $c$. A \temph{computation} is a (finite or infinite) sequence of configurations where for each two consecutive configurations $(c,c')$ in the sequence, $c \rightarrow c' \in T$. A \temph{run} is a computation starting from $c0$, which is \temph{complete} if it is infinite or ends in a terminal configuration.
\end{definition}


\subsection{Logic Programs Syntax}

The syntax of Logic Programs follows the standard in logic programming and Prolog, and is formally defined in Appendix~\ref{appendix:lp}. We note that $V$ denotes the set of all variables and $\calT$ the set of all terms.
We recall the quintessential logic program for list concatenation as an example:
\begin{example}[Append]
\begin{verbatim}
append([X|Xs], Ys, [X|Zs]) :- append(Xs, Ys, Zs).
append([], Ys, Ys).
\end{verbatim}
Logically, a logic program clause $A$\verb|:-| $B$ is a universally-quantified implication in which $B$ implies $A$, and a program is a conjunction of its clauses.
By convention, we use plural variable names like \verb|Xs| to denote a list of \verb|X|'s, 
\end{example}

\subsection{Logic Programs Operational Semantics}

\begin{definition}[Substitution, Instance, Unifier, Most-General Unifier]\label{definition:substitution}
A \temph{substitution} $\sigma$ is an idempotent function $\sigma: V \xrightarrow{} \calT$, namely a mapping from variables to terms applied to a fixed point. By convention, $\sigma(x)=x\sigma$.
\begin{itemize}
    \item Given a substitution $\sigma$, $V_\sigma := \{ X \in V ~|~ X\sigma \ne X\}$.
    \item Given a term $T \in \calT$ and a substitution $\sigma$,  $T\sigma$ is the term obtained from $T$ by replacing every variable $X \in T$ by the term $X\sigma$.
    \item The partial order on terms $\preceq \subset \calT \times \calT$ is defined by $T \preceq T'$, or $T'$ is an \temph{instance} of $T$, if there is a substitution $\sigma$ for which $T\sigma = T'$.
    If $T \ne T\sigma$ we say that $\sigma$ \temph{instantiates} $T$. 
   
    \item For substitutions $\sigma$ and $\sigma'$, $\sigma \preceq \sigma'$ if for every $T \in \calT$, $T\sigma \preceq T\sigma'$, $\sigma$ is \temph{as general as}  $\sigma'$ if $\sigma \preceq \sigma'$.
    \item A substitution $\sigma$ is a \temph{unifier} of two terms $T, T' \in \calT$ if $T\sigma = T'\sigma$; it is a \temph{most-general unifier (mgu)} of $T, T'$ if in addition it is as general as any other unifier of $T$ and $T'$.
\end{itemize}
\end{definition}

Namely, a most general unifier is frugal in not instantiating variables more than necessary.

\begin{remark}[Substitution as Assignment Set]
We  view a substitution $\sigma$ equivalently as a set of assignments $\{X_1:=T_1, \ldots, X_n:=T_n\}$ where $X_i\sigma = T_i$ and $T_i=T_i\sigma=T$. Thus the singleton substitution mapping $X$ to $T$ is $\{X:=T\}$, its application $T\sigma$ may be written $T\{X:=T\}$, the empty substitution is $\emptyset$, and composition of commutative substitutions corresponds to set union.
\end{remark}

\begin{definition}[Renaming, Rename apart]\label{definition:renaming}
A \temph{renaming} is a substitution $\sigma: V \mapsto V$ that maps variables to variables.
A renaming $\sigma$ renames $T'$ \temph{apart from} $T$ if $T'\sigma$ and $T$  have no variable in common.
\end{definition}
We assume a fixed renaming-apart function, so that the result of renaming $T'$ apart from $T$ is well defined.
Next we define the operational semantics of Logic Programs via a transition system.
 
\begin{definition}[LP Goal/Clause Reduction]\label{definition:logic-goal-clause-reduction}
Given LP goal $A$ and clause $C$,  with $H \verb|:-| B$ being the result of renaming $C$ apart from $A$, the \temph{LP reduction} of $A$ with $C$ \temph{succeeds with result} $(B,\sigma)$ if $A$ and $H$ have an mgu $\sigma$,  else \temph{fails}.
\end{definition}

\begin{definition}[Logic Programs Transition System]\label{definition:lp-ts}
A transition system $LP = (C,c0, T)$ is a \temph{Logic Programs transition system} for a logic program $M$ and initial goal $G_0 \in \mathcal{G}(M)$ if 
$C=\mathcal{G}(M)$, $c0=G_0$, and $T$
is the set of all transitions $G \rightarrow G' \in \mathcal{G}(M)^2$ such that for some atom $A \in G$ and clause $C \in M$  the LP reduction of $A$ with $C$ succeeds with result $(B,\sigma)$, and $G' = (G \setminus \{A\} \cup B)\sigma$.
\end{definition}
We write $G \xrightarrow{\sigma} G'$ when we want to make the substitution of a reduction explicit.
As a tribute to resolution theorem proving~\cite{robinson1965machine}—the intellectual ancestor of logic programming—a configuration of $LP$ is also referred to as a \emph{resolvent}.

Logic Programs have two forms of nondeterminism: the choice of $A\in G$, called \emph{and-nondeterminism}, and then choice of  $C\in M$, called \emph{or-nondeterminism}.  Thus, as an abstract model of computation, LP  are  closely-related to \emph{Alternating Turing Machines}, a generalization of Nondeterministic Turing Machines~\cite{shapiro1984alternation}.

\begin{definition}[Proper Run and Outcome]\label{definition:proper-run}
A run $\rho: G_0 \xrightarrow{\sigma_1} G_1 \xrightarrow{\sigma_2} \cdots \xrightarrow{\sigma_n} G_n$ of $LP$ is \temph{proper} if for any $1\le i<  n$,  a variable that occurs in  $G_{i+1}$ but not in  $G_i$ also does not occur in any $G_j$, $j<i$.   If proper, the \temph{outcome} of $\rho$ is $(G_0 \verb|:-| G_n)\sigma$ where $\sigma = \sigma_1 \circ \sigma_2 \circ \cdots \circ \sigma_n$.
\end{definition}
It so happens that the set of all outcomes of all proper runs of a logic program constitutes its fully-abstract compositional semantics~\cite{gaifman1989fully}.
Next we prove the key safety property of LP:

\begin{restatable}[LP Computation is Deduction]{proposition}{LPComputationisDeduction}\label{proposition:LP-computation-deduction}
The outcome\linebreak $(G_0$ :- $G_n)\sigma$ 
of a proper run $\rho: G_0 \xrightarrow{\sigma_1} G_1 \xrightarrow{\sigma_2} \cdots \xrightarrow{\sigma_n} G_n$ of $LP$, where $\sigma = \sigma_1 \circ \sigma_2 \circ \cdots \circ \sigma_n$,  is a logical consequence of $M$.
\end{restatable}

