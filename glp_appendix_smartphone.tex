\section{Implementation-Ready Multiagent GLP (irmaGLP)}\label{appendix:irmaGLP}

This appendix specifies irmaGLP, an implementation-ready transition system for multiagent (smartphone) GLP execution. It combines the implementation-ready structure of irGLP (Appendix~\ref{appendix:irGLP}) with the multiagent framework of maGLP (Section~\ref{section:maGLP}). While irGLP provides deterministic scheduling and suspension management for single agents, and maGLP defines cross-agent communication through shared variables, irmaGLP specifies the concrete data structures and message-passing mechanisms suitable for smartphone implementation.

A variable $X$ is \emph{fully local} to agent $p$ if $(X, \cdot, \cdot) \notin V_p$, meaning both $X$ and its dual counterpart are in $p$'s resolvent. Non-local variables require coordination through variable tables and explicit message passing, replacing maGLP's abstract shared-variable communication with concrete routing mechanisms.

The fundamental invariant: assignments produced by Reduce transactions are immediately applied if the reader is local, otherwise they become messages routed through the variable tables.

\subsection{Global Variable Identity}

Variables crossing agent boundaries require globally unique identifiers.

\begin{definition}[Global Variable Identity]\label{def:global-var-id}
A \temph{global variable identifier} has format $\textrm{creator}:\textrm{localId}$ where:
\begin{itemize}
\item $\textrm{creator} \in \Pi$: agent who allocated this variable
\item $\textrm{localId}$: unique integer within creator's heap
\end{itemize}
\end{definition}

For example, $\textrm{alice}:1042$ identifies the variable with local ID 1042 created by agent alice. When serializing terms for inter-agent transport, local variable IDs are replaced with global IDs to enable routing through variable tables.

\subsection{Transition System}

\begin{definition}[irmaGLP Transition System]\label{def:irmaglp-ts}
The implementation-ready maGLP transition system over agents $P \subset \Pi$ and GLP program $M$ is the multiagent transition system $\textrm{irmaGLP} = (\calC, c_0, \calT)$ where:
\begin{itemize}
\item $\calC$ is the set of all configurations where for each $p \in P$, the local state $c_p$ is an implementation-ready resolvent (Definition~\ref{def:irmaglp-local-state})
\item $c_0$ is the initial configuration where for each $p \in P$:
  \begin{itemize}
  \item $R_p = ([\textrm{agent}(p, \textrm{ch}(\_, \_), \textrm{ch}(\_, \_))], \emptyset, \emptyset)$
  \item $V_p = \emptyset$  
  \item $M_p = \emptyset$
  \end{itemize}
\item $\calT$ is the union of all transitions generated by:
  \begin{itemize}
  \item Unary Reduce transactions for each $p \in P$ (Definition~\ref{def:irmaglp-reduce})
  \item Binary Communicate transactions for each $(p, q) \in P \times P, p \neq q$ (Definition~\ref{def:irmaglp-communicate})
  \item Binary Network transactions for each $(p, q) \in P \times P, p \neq q$ (Definition~\ref{def:irmaglp-network})
  \end{itemize}
\end{itemize}
\end{definition}
 
\subsection{Local States}

\begin{definition}[irmaGLP Local State]\label{def:irmaglp-local-state}
The local state of agent $p \in \Pi$ is an \temph{implementation-ready resolvent} $s_p = (R_p, V_p, M_p)$ where:
\begin{enumerate}
\item $R_p = (A_p, S_p, F_p)$ separates the resolvent goals into three types:
    \begin{itemize}
    \item \textbf{Active:} $A_p \in \calA_?^*$ 
    \item \textbf{Suspended:} $S_p \subseteq \calA_? \times 2^{\calV?}$ 
    \item \textbf{Failed:} $F_p \subseteq \calA_?$
    \end{itemize}
    
   \item $V_p \subseteq (\calV \cup \calV?) \times \Pi \times (\calT \cup \Pi \cup \{\bot\})$ maintains shared variable state as a set of triples $(Y, q, s)$:
        \begin{itemize}
        \item \textbf{Writer:} $Y \in \calV$, $q = p$ (invariant: writers are always created locally, never imported), $s \in \calT$ is the value of $Y$, else $s=\bot$. The dual reader $Y?$ is non-local.
        \item \textbf{Created Reader:} $Y \in \calV?$, $q = p$, $s \in \Pi$ is the read-requesting agent, else $s=\bot$. The dual writer is non-local.
        \item \textbf{Imported Reader:} $Y \in \calV?$, $q \neq p$ (creator), $s = q$ indicates a read request has been sent from $p$ to $q$, else $s=\bot$. Both $Y$ and its dual writer are non-local to $p$.
        \end{itemize}
        
\item $M_p$ is a set of pending messages as pairs (content, destination) where destination $q \in \Pi$:
    \begin{itemize}
    \item assignments $(X?:=T, q)$ 
    \item read requests $(\textrm{request}(X?, p), q)$ where $p$ requests $X?$ from $q$
    \item abandonment notifications $(\textrm{abandon}(X), q)$
    \end{itemize}
\end{enumerate}
\end{definition}

The resolvent $R_p$ partitions goals into three categories. Active goals $A_p$ contains a queue of goals to be reduced in FIFO order. Suspended goals $S_p$ pairs each atom with the set of readers preventing its reductionâ€”for $(A, W) \in S_p$, the set $W$ contains all readers from the suspension sets across all clause attempts. When any reader $X? \in W$ receives a value or is abandoned, $A$ moves to the tail of $A_p$. Failed goals $F_p$ contains atoms for which every reduction attempt either failed outright or suspended only on abandoned variables.

The variable table $V_p$ maintains shared variables where one element of each variable pair is local to $p$ while its dual is non-local. For writers, the table stores the creator (always $p$) and any assignment to enable response to read requests. For created readers, it records which agent has requested the value. For imported readers, it tracks whether a read request has been sent to the creator. This unified structure ensures variables referenced by non-local duals are not prematurely garbage collected and provides routing information for cross-agent communication.

The variable table $V_p$ maintains an invariant: it contains exactly those variables whose dual counterparts are non-local. When $p$ receives a term containing a variable from $V_p$, that variable becomes fully local and must be removed from $V_p$. When $p$ exports a term, the export helper function updates $V_p$ accordingly: variables created by $p$ are added when first exported, while variables created by others are removed (except for requested readers which require relay variables).

\subsection{Helper Routines}

The following helper routines are used by the transactions. All routines operate on agent $p$'s state and may modify $V'_p$ and $M'_p$.

\begin{definition}[Routine: abandon$(Y?)$]\label{def:routine-abandon}
The \textrm{abandon} routine notifies other agents when reader $Y?$ becomes unreachable. An agent can only abandon a \textbf{reader}, which causes the remote agent holding the dual writer to be notified.
\begin{itemize}
\item If $(Y?, q, s) \in V_p$ where $q \neq p$: remove from $V'_p$ and add $(\textrm{abandon}(Y), q)$ to $M'_p$
\item If $(Y?, p, s) \in V_p$ and $s \neq \bot$: remove from $V'_p$ and add $(\textrm{abandon}(Y), s)$ to $M'_p$
\item Otherwise: just remove $(Y?, \cdot, \cdot)$ from $V'_p$ if present
\end{itemize}
where $Y$ is the dual writer of $Y?$ (the message contains the writer so the receiver knows which variable was abandoned).
\end{definition}

\begin{definition}[Routine: request$(X?)$]\label{def:routine-request}
The \textrm{request} routine sends a read request for an imported reader that hasn't been requested yet. It updates the table entry from $(X?, q, \bot)$ to $(X?, q, q)$ to record that the request was sent, preventing duplicate requests.

If $(X?, q, \bot) \in V'_p$ and $q \neq p$ then:
\begin{itemize}
\item Update to $(X?, q, q)$ in $V'_p$ 
\item Add $(\textrm{request}(X?, p), q)$ to $M'_p$
\end{itemize}
\end{definition}

\begin{definition}[Routine: export$(T)$ returns $T'$]\label{def:routine-export}
The \textrm{export} routine updates the variable table when term $T$ is sent outside agent $p$. Variables created by $p$ are added to $V_p$ when first exported. Imported variables are typically removed since they're no longer local, except for requested readers which require special handling: a fresh relay pair $(Z, Z?)$ is created with a forwarding goal to maintain the request relationship while allowing the original reader to leave $p$'s scope.

Set $T' := T$. For each variable $Y$ occurring in $T$:
\begin{itemize}
\item \textbf{Local:} If $Y$ created by $p$ and $(Y, p, \cdot) \notin V'_p$: add $(Y, p, \bot)$ to $V'_p$
\item \textbf{Non-local:} If $Y$ created by $q \neq p$ then:
    \begin{itemize}
    \item \textbf{Writer or Non-requested Reader:} If $Y \in \calV$ or $(Y, q, \bot) \in V'_p$ then remove $(Y, q, \cdot)$ from $V'_p$
    \item \textbf{Requested Reader:} If $(Y, q, q) \in V'_p$ then create fresh pair $(Z, Z?)$, replace $Y$ with $Z?$ in $T'$, add $\textrm{relay}(Y, Z)$ to $A'_p$, add $(Z?, p, \bot)$ to $V'_p$
    \end{itemize}
\end{itemize}
Return $T'$ (the result of applying variable replacements, if any, to $T$).
\end{definition}

The forwarding goal $\textrm{relay}(Y, Z)$ is defined as:
\begin{verbatim}
relay(Y, Z) :- known(Z?) | Y = Z?.
\end{verbatim}
This ensures that when relay reader $Z?$ receives a value $V$, the original writer $Y$ is bound to $V$, maintaining the request relationship across export boundaries.

\begin{definition}[Routine: reactivate$(X?)$ returns $R$]\label{def:routine-reactivate}
The \textrm{reactivate} routine finds and removes goals suspended on reader $X?$:
\begin{itemize}
\item Let $R = \{G : (G, W) \in S'_p, X? \in W\}$
\item $S'_p := S'_p \setminus \{(G, W) : G \in R\}$
\item Return $R$
\end{itemize}
\end{definition}

\subsection{Transactions}

\mypara{Variable Abandonment}
During goal reduction, readers may become abandoned when they disappear from the computation without being instantiated. This happens when a reader that occurs in the reduced atom is neither instantiated by the reduction nor occurring in the resulting body.

\begin{definition}[Reader Abandonment in Reduction]\label{def:reader-abandonment}
When reducing atom $A$ with clause $C$ yielding body $B$ and substitution $\hat\sigma$, a reader $Y?$ is \temph{abandoned} if all three conditions hold:
\begin{enumerate}
\item $Y?$ occurs in $A$
\item $Y?$ is not instantiated by $\hat\sigma?$
\item $Y?$ does not occur in $B$
\end{enumerate}
For each abandoned reader $Y?$, call $\textrm{abandon}(Y?)$ to notify the creator holding the dual writer $Y$.
\end{definition}

\begin{definition}[irmaGLP Reduce Transaction]\label{def:irmaglp-reduce}
The unary Reduce transaction for agent $p$ transitions $(R_p, V_p, M_p) \rightarrow (R'_p, V'_p, M'_p)$ where $R_p = (A_p, S_p, F_p)$, initializing $(R'_p, V'_p, M'_p) := (R_p, V_p, M_p)$ with $A_p = A \cdot A_r$ for head goal $A$:

\begin{enumerate}
\item \textbf{Reduce:} If GLP reduction of $A$ with first applicable clause $C \in M$ succeeds with $(B, \hat\sigma)$:
\begin{itemize}
    \item Let $W = \{X? : \{X?:=T\} \in \hat\sigma?\}$ be the readers assigned by this reduction
    \item Let $R = \bigcup_{X? \in W} \textrm{reactivate}(X?)$ (modifies $S'_p$)
    \item $A'_p := (A_r \cdot B \cdot R)\hat\sigma\hat\sigma?$
    \item Update $M'_p$: add $(X?:=T, r)$ for each $\{X?:=T\} \in \hat\sigma?$ where $(X?, p, r) \in V'_p, r \neq \bot$
    \item Call abandon$(Y?)$ for each abandoned reader $Y?$ (Definition~\ref{def:reader-abandonment})
\end{itemize}

\item \textbf{Suspend:} Else if $W = \bigcup_{C \in M} W_C \neq \emptyset$:
\begin{itemize}
    \item $A'_p := A_r$
    \item $S'_p := S'_p \cup \{(A, W)\}$
    \item Call request$(X?)$ for each $X? \in W$ (modifies $V'_p$ and $M'_p$)
\end{itemize}

\item \textbf{Fail:} Else:
\begin{itemize}
    \item $A'_p := A_r$
    \item $F'_p := F'_p \cup \{A\}$
    \item Call abandon$(Y?)$ for each reader $Y?$ in $A$ (modifies $V'_p$ and $M'_p$)
\end{itemize}
\end{enumerate}
Then $R'_p := (A'_p, S'_p, F'_p)$.
\end{definition}

\begin{definition}[irmaGLP Communicate Transaction]\label{def:irmaglp-communicate}
The binary Communicate transaction $(c_p, c_q) \rightarrow (c'_p, c'_q)$ where $p \neq q$ and $(m, q) \in M_p$. Initialize $(c'_p, c'_q) := (c_p, c_q)$, remove $(m, q)$ from $M'_p$, and case on $m$:
\begin{enumerate}
\item \textbf{Assignment} $m = (X?:=T)$ where $X?$ is local to $q$: 
\begin{itemize}
    \item Let $R = \textrm{reactivate}(X?)$ for agent $q$ (modifies $S'_q$)
    \item If $T \neq \bot$: $A'_q := (A_q \cdot R)\{X?:=T\}$, and apply $\{X?:=T\}$ to $S'_q$ and $F_q$
    \item Else: $A'_q := A_q \cdot R$
    \item Remove $(X?, \cdot, \cdot)$ from $V'_q$
    \item For each variable $Y$ in $T$ where $(Y, \cdot, \cdot) \notin V'_q$: if $Y$ created by agent $r$, add $(Y, r, \bot)$ to $V'_q$
\end{itemize}
 
\item \textbf{Read Request} $m = \textrm{request}(X?, p)$:
\begin{itemize}
    \item If $p = \bot$ then call abandon$(X?)$ for agent $q$ (modifies $V'_q$ and $M'_q$)
    \item Else if $(X?, q, \bot) \in V'_q$ then update to $(X?, q, p)$ in $V'_q$
    \item Else if $(X, q, T) \in V'_q$ then add $(X?:=T, p)$ to $M'_q$
\end{itemize}
\end{enumerate}
\end{definition}

\begin{definition}[irmaGLP Network Transaction]\label{def:irmaglp-network}
The binary Network transaction $(c_p, c_q) \rightarrow (c'_p, c'_q)$ where $p \neq q$ and a new \verb|msg|$(q, X)$ appears in $p$'s network output stream. Initialize $(c'_p, c'_q) := (c_p, c_q)$:
\begin{itemize}
\item Let $X' := \textrm{export}(X)$ for agent $p$ (modifies $V'_p$ and $M'_p$)
\item Add $X'$ to $q$'s network input stream
\item For each variable $Y$ in $X'$ where $(Y, \cdot, \cdot) \notin V'_q$: if $Y$ created by agent $r$, add $(Y, r, \bot)$ to $V'_q$
\end{itemize}
\end{definition}

\begin{remark}[Deterministic Scheduling]
The scheduler operates deterministically by selecting the head of the active queue $A_p$. When any reader $X? \in W$ for a suspended goal $(A, W) \in S_p$ receives a value or is marked abandoned, the goal $A$ is moved from $S_p$ to $A_p$ for re-evaluation. Goals in $F_p$ remain terminal, preserving logical completeness while enabling runtime fault analysis.
\end{remark}

\subsection{Extensions for Secure Multiagent GLP}

To extend irmaGLP to Secure maGLP, the following cryptographic mechanisms augment the definitions without modifying their structure.

\subsubsection{Agent Identity and Cryptography}

Each agent $p \in \Pi$ is augmented with:
\begin{itemize}
\item A self-chosen keypair $(pk_p, sk_p)$ where the public key $pk_p$ serves as the agent's identity
\item The agent identifier $p$ is synonymous with $pk_p$ throughout the system
\item Knowledge of other agents' public keys through social contacts
\end{itemize}

\subsubsection{Message Authentication and Encryption}

All messages in $M_p$ are cryptographically protected. A message $(m, q) \in M_p$ becomes $(m_{M,p,q}, q)$ where the subscript notation indicates:
\begin{itemize}
\item $M$: Attestation by the GLP runtime proving $m$ resulted from correct execution of module $M$
\item $p$: Digital signature using agent $p$'s private key $sk_p$
\item $q$: Encryption using agent $q$'s public key $pk_q$
\end{itemize}

\subsubsection{Transaction Augmentations}

\mypara{Reduce Transaction}
When generating messages $(X?:=T, r)$ for remote readers, the implementation creates $(X?:=T)_{M,p,r}$ with attestation proving the assignment resulted from correct goal/clause reduction using module $M$.

\mypara{Communicate Transaction}
Before processing any received message $(m_{M,p,q}, q)$:
\begin{enumerate}
\item Decrypt using $q$'s private key $sk_q$
\item Verify signature using $p$'s public key $pk_p$
\item Validate attestation for module $M$
\item Discard the message if any verification fails
\item Process according to Definition~\ref{def:irmaglp-communicate} only if all verifications succeed
\end{enumerate}

\mypara{Network Transaction}
Network messages \verb|msg|$(q, X)$ are similarly protected as $(\verb|msg|(q, X))_{M,p,q}$ ensuring authenticated channel establishment.

\subsubsection{Module Verification}

\begin{itemize}
\item Each agent executes a verified GLP module $M$ with a cryptographic hash identifier
\item Attestations include the module hash, enabling recipients to verify code compatibility
\item Guard predicates \verb|attestation(X, att(Agent, Module))| and \verb|module(M)| provide program-level access to verification results
\end{itemize}

\subsubsection{Security Properties Achieved}

These extensions ensure:
\begin{itemize}
\item \textbf{Integrity}: Messages cannot be modified without detection
\item \textbf{Confidentiality}: Only intended recipients can decrypt messages
\item \textbf{Non-repudiation}: Senders cannot deny authenticated messages
\item \textbf{Authentication}: All inter-agent communication is mutually authenticated
\end{itemize}

The implementation-ready transition system with these cryptographic extensions realizes Secure maGLP while maintaining the same operational behaviour for correctly authenticated participants. Byzantine agents who fail verification are effectively excluded from the computation through message rejection.
