\section{Smartphone Implementation-ready Multiagent Transition System for GLP}\label{appendix:irmaGLP}

This section combines the implementation-ready structure of irGLP (Section~\ref{appendix:irGLP}) with the multiagent framework of maGLP (Section~\ref{section:maGLP}). While irGLP provides deterministic scheduling and suspension management for single agents, and maGLP defines cross-agent communication through shared variables, irmaGLP specifies the concrete data structures and message-passing mechanisms suitable for multiagent smartphone implementation.

A variable $X$ is \emph{local} to agent $p$ if $X$ occurs in $p$'s resolvent. Non-local variables require coordination through variable tables and explicit message passing, replacing maGLP's abstract shared-variable communication with concrete routing mechanisms.

The fundamental invariant: assignments produced by Reduce transactions are immediately applied if the reader is local, otherwise they become messages routed through the variable tables.

\begin{definition}[Implementation-Ready maGLP Transition System]
The implementation-ready maGLP transition system over agents $P \subset \Pi$ and GLP module $M$ is the multiagent transition system $\text{IRmaGLP} = (C, c_0, T)$ where:
\begin{itemize}
\item $C$ is the set of all configurations where for each $p \in P$, the local state $c_p$ is an implementation-ready resolvent as in Definition~\ref{definition:IRmaGLP-local-state}
\item $c_0$ is the initial configuration where for each $p \in P$:
  \begin{itemize}
  \item $R_p = ([\texttt{agent}(p, \texttt{ch}(_?, _), \texttt{ch}(_?, _))], \emptyset, \emptyset)$
  \item $V_p = \emptyset$  
  \item $M_p = \emptyset$
  \end{itemize}
\item $T$ is the union of all transitions generated by:
  \begin{itemize}
  \item Unary Reduce transactions for each $p \in P$ (Definition~\ref{definition:IRmaGLP-reduce})
  \item Binary Communicate transactions for each $(p, q) \in P \times P, p \neq q$ (Definition~\ref{definition:IRmaGLP-communicate})
  \item Binary Network transactions for each $(p, q) \in P \times P, p \neq q$ (Definition~\ref{definition:IRmaGLP-network})
  \end{itemize}
\end{itemize}
\end{definition}
 
\subsection{Local States}

\begin{definition}[Implementation-Ready maGLP Local State]\label{definition:IRmaGLP-local-state}
The local state of agent $p \in \Pi$ is an \temph{implementation-ready resolvent} $s_p = (R_p, V_p,M_p)$ where:
\begin{enumerate}
\item $R_p = (A_p, S_p, F_p)$ separates the resolvent goals into three types:
    \begin{itemize}
    \item \textbf{Active: }$A_p\in \calA^*$ 
    \item \textbf{Suspended:} $S_p \subseteq \mathcal{A} \times 2^{V?}$ 
    \item \textbf{Failed:} $F_p \subseteq \mathcal{A}$
    \end{itemize}
    
   \item $V_p \subseteq \calV \times \Pi \times (\mathcal{T} \cup \Pi \cup \{\bot\})$ maintains shared variable state as a set of triples where each $(Y, q, s) \in V_p$:
        \begin{itemize}
        \item \textbf{Writer:} $Y \in V$,  $s \in \mathcal{T}$ is the value of $Y$, else $s=\bot$
        \item \textbf{Created Reader:} $Y \in V?$, $q = p$, $s \in \Pi$ is the read-requesting agent, else $s=\bot$
        \item  \textbf{Imported Reader:} $Y \in V?$ (reader),  $q \neq p$, $s =q$ indicates a read request has been sent from $p$ to $q$, else  $s=\bot$ 
        \end{itemize}
        
\item $M_p$ is a set of pending messages as pairs (content, destination) where destination $q \in \Pi$:
    \begin{itemize}
    \item assignments $(X?:=T, q)$ 
    \item read requests $(request(X?, p), q)$ where $p$ requests $X?$ from $q$
    \item abandonment notifications $(abandon(X), q)$
    \end{itemize}
\end{enumerate}
\end{definition}

The resolvent $R_p$ partitions goals into three categories. Active goals $A_p$ contains a queue of goals to be reduced in FIFO order. Suspended goals $S_p$ pairs each atom with the set of readers preventing its reductionâ€”for $(A, W) \in S_p$, the set $W$ contains all readers from the suspension sets across all clause attempts. When any reader $X? \in W$ receives a value or is abandoned, $A$ moves to the tail of $A_p$. Failed goals $F_p$ contains atoms for which every reduction attempt either failed outright or suspended only on abandoned variables.

The variable table $V_p$ maintains shared variables where one element of each reader/writer pair is local to $p$ while its counterpart is non-local. For writers, the table stores the creator and any assignment to enable response to read requests. For created readers, it records which agent has requested the value. For imported readers, it tracks whether a read request has been sent to the creator. This unified structure ensures variables referenced by non-local counterparts are not prematurely garbage collected and provides routing information for cross-agent communication.

The variable table $V_p$ maintains an invariant: it contains exactly those variables whose paired counterparts are non-local. When $p$ receives a term containing a variable from $V_p$, that variable becomes local and must be removed from $V_p$. When $p$ exports a term, the export helper function updates $V_p$ accordingly: variables created by $p$ are added when first exported, while variables created by others are removed (except for requested readers which require relay variables).

\mypara{Helper Routines for Implementation-Ready Transactions, agent $p$}

The \texttt{abandon} helper notifies other agents when variable $Y$ becomes unreachable. For imported variables, it notifies the creator $q$. For created readers with a requester $s$, it notifies that requester. The paired variable $Y'$ is sent in the message to indicate which part of the pair was abandoned.

\begin{definition}[routine abandon(Y)]
\begin{itemize}
\item If $(Y, q, s) \in V_p$ where $q \neq p$: remove from $V'_p$ and add $(abandon(Y'), q)$ to $M'_p$
\item If $(Y, p, s) \in V_p$ and $s \neq \bot$: remove from $V'_p$ and add $(abandon(Y'), s)$ to $M'_p$
\item Otherwise: just remove $(Y, \cdot, \cdot)$ from $V'_p$ if present
\end{itemize}
where $Y' = Y?$ if $Y \in V$, else $Y' = Y$ if $Y \in V?$ (the paired variable)
\end{definition}

The \texttt{request} helper sends a read request for an imported reader that hasn't been requested yet. It updates the table entry from $(X?, q, \bot)$ to $(X?, q, q)$ to record that the request was sent, preventing duplicate requests.

\begin{definition}[routine request(X?)]
If $(X?, q, \bot) \in V'_p$ and $q \neq p$ then:
\begin{itemize}
\item Update to $(X?, q, q)$ in $V'_p$ 
\item Add $(request(X?, p), q)$ to $M'_p$
\end{itemize}
\end{definition}

The \texttt{export} helper updates the variable table when term $T$ is sent outside agent $p$. Variables created by $p$ are added to $V_p$ when first exported. Imported variables are typically removed since they're no longer local, except for requested readers which require special handling: a fresh relay pair $(Z, Z?)$ is created with a forwarding goal to maintain the request relationship while allowing the original reader to leave $p$'s scope.

\begin{definition}[routine export$(T)$ returns $T'$]
\begin{itemize}
Set $T' := T$
\item For each variable $Y$ occurring in $T$:
    \begin{itemize}
    \item \textbf{Local:} If $Y$ created by $p$ and $(Y, p, \cdot) \notin V'_p$: add $(Y, p, \bot)$ to $V'_p$
    \item \textbf{Non-local:} If $Y$ created by $q \neq p$ then
        \begin{itemize}
        \item \textbf{Writer or Non-requested Reader:} If $Y \in V$ or $(Y, q, \bot) \in V'_p$ then remove $(Y, q, \cdot)$ from $V'_p$
        \item \textbf{Requested Reader:} If $(Y, q, q) \in V'_p$  then create fresh pair $(Z, Z?)$, replace $Y$ with $Z?$ in $T'$, add $\text{export\_reader}(Y, Z)$ to $A'_p$, add $(Z?, p, \bot)$ to $V'_p$
        \end{itemize}
    \end{itemize}
\end{itemize}
$T'$ is the result of applying variable replacements (if any) to $T$.
\end{definition}

\begin{definition}[routine reactivate(X?) for agent p returns R]
\begin{itemize}
\item Let $R = \{G : (G, W) \in S'_p, X? \in W\}$
\item $S'_p := S'_p \setminus \{(G, W) : G \in R\}$
\item Return $R$
\end{itemize}
\end{definition}

\subsection{Transactions}

Next, we describe the implementation-ready maGLP transactions one by one:

\mypara{Abandoned variables}
During goal reduction, variables may become abandoned when their paired counterparts disappear from the computation without being instantiated. This happens when a variable that occurs in the reduced atom is neither instantiated by the reduction nor occurring in the resulting body. The implementation should detect such abandonment to prevent indefinite suspension or shared-variable entries for variables that can never receive values. Abandoned variables allow garbage-collection in shared variable tables and cause dependent suspended goals to fail rather than wait indefinitely.

\begin{definition}[Variable Abandonment in Reduction]
When reducing atom $A$ with clause $C$ yielding body $B$ and substitution $\hat\sigma$, a variable $Y$ is \emph{abandoned} if its paired variable $Y'$ satisfies all three conditions: $Y'$ occurs in $A$, $Y'$ is not instantiated by $\hat\sigma$ or $\hat\sigma?$  , and $Y'$ does not occur in $B$.
\end{definition}

\begin{definition}[Implementation-Ready Reduce Transaction]\label{definition:IRmaGLP-reduce}
The unary Reduce transaction for agent $p$ transitions $(R_p, V_p, M_p) \rightarrow (R'_p, V'_p, M'_p)$ where $R_p = (A_p, S_p, F_p)$,  $(R'_p, V'_p, M'_p): = (R_p, V_p, M_p)$ with $A_p = A \cdot A_r$ for head goal $A$:

\begin{enumerate}
\item \textbf{Reduce:} If GLP reduction of $A$ with first applicable clause $C \in M$ succeeds with $(B,\hat\sigma)$:
\begin{itemize}
    \item Let $R = \bigcup_{X? \in V_{\hat\sigma?}} \text{reactivate}(X?)$ (modifies $S'_p$)
    \item $A'_p := (A_r \cdot B \cdot R)\hat\sigma\hat\sigma?$
    \item Update $V'_p$: for each $X? \in W$ where $(X?, q, \bot) \in V'_p$, update to $(X?, q, q)$
    \item Update $M'_p$: add $(X?:=T, r)$ for each $\{X?:=T\} \in \hat\sigma?$ where $(X?, p, r) \in V'_p, r \neq \bot$
    \item Call abandon$(Y)$ for each abandoned variable $Y$
\end{itemize}

\item \textbf{Suspend:} Else if $W = \bigcup_{C \in M} W_{C} \neq \emptyset$:
\begin{itemize}
    \item $A'_p := A_r$
    \item $S'_p := S'_p \cup \{(A, W)\}$
    \item Call request$(X?)$ for each $X? \in W$ (modifies $V'_p$ and $M'_p$)
\end{itemize}

\item \textbf{Fail:} Else:
\begin{itemize}
    \item $A'_p := A_r$
    \item $F'_p := F'_p \cup \{A\}$
    \item Call abandon$(Y)$ for each variable $Y$ in $A$ (modifies $V'_p$ and $M'_p$)
\end{itemize}
\end{enumerate}
Then $R'_p := (A'_p, S'_p, F'_p)$.
\end{definition}

\begin{definition}[Implementation-Ready Communicate Transaction]\label{definition:IRmaGLP-communicate}
The binary Communicate transaction $(c_p,c_q) \rightarrow (c'_p,c'_q)$ where $p \neq q$ and $(m, q) \in M_p$. Set $(c'_p, c'_q) := (c_p, c_q)$, remove $(m, q)$ from $M'_p$, and case:
\begin{enumerate}
\item \textbf{Assignment} $m = (X?:=T)$ where $X?$ is local to $q$: 
\begin{itemize}
    \item Let $R = $ reactivate$(X?)$ for agent $q$ (modifies $S'_q$)
    \item If $T \neq \bot$: $A'_q := (A_q \cdot R)\{X?:=T\}$, and apply $\{X?:=T\}$ to $S'_q$ and $F_q$
    \item Else: $A'_q := A_q \cdot R$
    \item Remove $(X?, \cdot, \cdot)$ from $V'_q$
    \item For each variable $Y$ in $T$ not already local to $q$ and created by $r$: add $(Y, r, \bot)$ to $V'_q$
\end{itemize}
 
\item \textbf{Read Request} $m = \text{request}(X?, p)$:
\begin{itemize}
    \item If $p = \bot$ then call abandon$(X?)$ for agent $q$ (modifies $V'_q$ and $M'_q$)
    \item Else if $(X?, q, \bot) \in V'_q$ then update to $(X?, q, p)$ in $V'_q$
    \item Else if $(X, q, T) \in V'_q$ then add $(X?:=T, p)$ to $M'_q$
\end{itemize}
\end{enumerate}
\end{definition}

\begin{definition}[Implementation-Ready Network Transaction]\label{definition:IRmaGLP-network}
The binary Network transaction $(c_p,c_q) \rightarrow (c'_p,c'_q)$ where $p \neq q$ and a new \verb|msg|$(q,X)$ appears in $p$'s network output stream. Set $(c'_p, c'_q) := (c_p, c_q)$:
\begin{itemize}
\item Let $X' := \text{export}(X)$ for agent $p$ (modifies $V'_p$ and $M'_p$)
\item Add $X'$ to $q$'s network input stream
\item For each variable $Y$ in $X'$ not already local to $q$ and created by $r$: add $(Y, r, \bot)$ to $V'_q$
\end{itemize}
\end{definition}

The scheduler operates deterministically by selecting the head of the active queue $A_p$. When any reader $X? \in W$ for a suspended goal $(A, W) \in S_p$ receives a value or is marked abandoned, the goal $A$ is moved from $S_p$ to $A_p$ for re-evaluation. Goals in $F_p$ remain terminal, preserving logical completeness while enabling runtime fault analysis.

\subsection{Extensions for Secure Multiagent GLP}

To extend the implementation-ready transition system to Secure maGLP, the following cryptographic mechanisms augment the definitions without modifying their structure:

\subsubsection{Agent Identity and Cryptography}

Each agent $p \in \Pi$ is augmented with:
\begin{itemize}
\item A self-chosen keypair $(pk_p, sk_p)$ where the public key $pk_p$ serves as the agent's identity
\item The agent identifier $p$ is synonymous with $pk_p$ throughout the system
\item We assume knowledge of  other agents' public keys through social contacts
\end{itemize}

\subsubsection{Message Authentication and Encryption}

All messages in $M_p$ are cryptographically protected. A message $(m, q) \in M_p$ becomes $(m_{M,p,q}, q)$ where the subscript notation indicates:
\begin{itemize}
\item $M$: Attestation by the GLP runtime proving $m$ resulted from correct execution of module $M$
\item $p$: Digital signature using agent $p$'s private key $sk_p$
\item $q$: Encryption using agent $q$'s public key $pk_q$
\end{itemize}

\subsubsection{Transaction Augmentations}

\paragraph{Reduce Transaction}
When generating messages $(X?:=T, r)$ for remote readers, the implementation creates $(X?:=T)_{M,p,r}$ with attestation proving the assignment resulted from correct goal/clause reduction using module $M$.

\paragraph{Communicate Transaction}
Before processing any received message $(m_{M,p,q}, q)$:
\begin{enumerate}
\item Decrypt using $q$'s private key $sk_q$
\item Verify signature using $p$'s public key $pk_p$
\item Validate attestation for module $M$
\item Discard the message if any verification fails
\item Process according to Definition~\ref{definition:IRmaGLP-communicate} only if all verifications succeed
\end{enumerate}

\paragraph{Network Transaction}
Network messages \verb|msg|$(q,X)$ are similarly protected as (\verb|msg|$(q,X))_{M,p,q}$ ensuring authenticated channel establishment.

\subsubsection{Module Verification}

\begin{itemize}
\item Each agent executes a verified GLP module $M$ with a cryptographic hash identifier
\item Attestations include the module hash, enabling recipients to verify code compatibility
\item Guard predicates \verb|attestation(X, att(Agent, Module))| and \verb|module(M)| provide program-level access to verification results
\end{itemize}

\subsubsection{Security Properties Achieved}

These extensions ensure:
\begin{itemize}
\item \textbf{Integrity}: Messages cannot be modified without detection
\item \textbf{Confidentiality}: Only intended recipients can decrypt messages
\item \textbf{Non-repudiation}: Senders cannot deny authenticated messages
\item \textbf{Authentication}: All inter-agent communication is mutually authenticated
\end{itemize}

The implementation-ready transition system with these cryptographic extensions realizes Secure maGLP while maintaining the same operational behaviour for correctly authenticated participants. Byzantine agents who fail verification are effectively excluded from the computation through message rejection.

\end{document}
