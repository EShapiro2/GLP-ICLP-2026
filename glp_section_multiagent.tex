\section{Multiagent GLP}\label{section:maGLP}

We first extend the notion of transition systems to multiagent transition systems,  then use them to extend GLP to multiagent GLP, and finally recall the definition of grassroots protocols~\cite{shapiro2023grassrootsBA} and prove that multiagent GLP is grassroots.

\subsection{Multiagent transition systems and atomic transactions} 

We assume a potentially infinite set of \emph{agents} $\Pi$ (think of all the agents that are yet to be born), but consider only finite subsets of it,  so when we refer to a particular set of agents $P \subset \Pi$ we assume $P$ to be nonempty and finite.
We extend the notion of transition systems (Definition~\ref{definition:ts}) to be multiagent~\cite{shapiro2023grassrootsBA,shapiro2025atomic}:

Informally, a multiagent configuration $c$ over $P$ and a set of local states $S$ can be thought of as an array indexed by agents in $P$, with $c_p\in S$, the local state of $p$ in $c$, being the array element in $c$ indexed by $p$.

\begin{definition}[Multiagent Transition System, Degree]\label{definition:mts}
Given agents $P \subset \Pi$ and an arbitrary set $S$ of \temph{local states} with a designated \temph{initial local state} $s0\in S$, 
a \temph{multiagent transition system} over $P$ and $S$ is a transition system $TS= (C,c0,T)$ with $C:= S^P$,  $c0:= \{s0\}^P$, and $T\subseteq C^2$ being a set of \temph{multiagent transitions} over $P$ and $S$. For $c\in C$ and $p\in P$, let $c_p$ denote the $p$-indexed element of $c$, define $TS$ to be of \temph{degree} $k$  (unary, binary, $k$-ary) if $k$ is the minimal number such that for every transition $c \rightarrow c' \in T$, at most $k$ agents $p\in P$ change their local state, $c_p \neq c'_p$.
\end{definition}



\begin{definition}[Transaction, Closure]\label{definition:closure}
Let $P\subset \Pi$, $S$ a set of local states, and $C:=S^P$. 
A \temph{transaction} $t=(c\rightarrow c')$ over local states $S$ with \temph{participants} $Q \subset \Pi$ is but a multiagent transition over $S$ and $Q$, with $t_p := (c_p\rightarrow c'_p)$ for any $p\in Q$.
For every $P\subset \Pi$ s.t.  $Q\subseteq P$, the \temph{$P$-closure of $t$}, $t{\uparrow}P$,  is the set of transitions over $P$ and $S$ defined by:
$$
t{\uparrow}P := \{ t' \in C^2  :
\forall p\in Q.(t_p = t'_p) \wedge \forall p\in P\setminus Q.(p\text{ is stationary in }t')\}
$$
If $R$ is a set of transactions, each $t\in R$ over some $Q\subseteq P$ and $S$, then the 
\temph{$P$-closure of $R$}, $R{\uparrow}P$, is the set of $P$-transitions 
$ R{\uparrow}P := \bigcup_{t\in R} t{\uparrow}P$.
\end{definition}
Namely, the closure over $P\supseteq Q$ of a transaction $t$ over $Q$ includes all transitions $t'$ over $P$ in which members of $Q$ do the same in $t$ and in $t'$, and the rest remain in their current (arbitrary) state.  A set of transactions $R$ over $S$, each with participants $Q\subseteq P$, defines a multiagent transition system as follows:

\begin{definition}[Transactions-Based Multiagent Transition System]\label{definition:tbdts}
Given agents $P \subset \Pi$, local states $S$ with initial local state $s0\in S$, 
and a set of transactions $R$, each $t\in R$ over some $Q\subseteq P$ and  $S$, a \temph{transactions-based multiagent transition system} over $P$, $S$, and $R$ is the multiagent transition system $TS= (S^P,\{s0\}^P,R{\uparrow}P)$ .
\end{definition}

In other words, one can fully specify a multiagent transition system over $S$ and $P$ simply by providing a set of atomic transactions over $S$, each with participants $Q\subseteq P$.  Reference~\cite{shapiro2025atomic} provided transactions-based specification for social networks, grassroots cryptocurrencies, and grassroots federations.  Here we do that for multiagent GLP.

\subsection{Multiagent GLP} 

We extend GLP to be multiagent by letting agents' local states to be asynchronous resolvents, have unary Reduce transitions in which agents reduce a local goal and add reader assignments to its pending assignments; and binary Communicate transitions between agents $p$ and $q$ in case $p$ has a pending $X?:=T$ and $X?$ occurs in the resolvent of $q$.

A key difference between GLP and multiagent GLP is in the initial state. In a multiagent transition systems all agents must have the same initial state $s0$.  This precludes setting up an initial configuration/goal in which agents share logic variables, as this would imply different initial states for different agents.

We resolve this conundrum in two steps.  First, we employ only anonymous logic variables ``\verb|_|'' in the initial local states of agents:  Anonymous variables are, on the one hand, syntactically identical, hence allow all initial states to be syntactically identical, and on the other hand represent unique variables, hence semantically all initial goals have unique, local, non-shared variables.  
The initial state of all agents is the atomic goal \verb|agent(ch(_?,_),ch(_?,_))|, with the first channel serving communication with the user and the second with the network. 

Additional magic is needed to bootstrap communication between agents, so that agents that wish to communicate can have a shared variable to do so with. To address that we assume that the network connecting agents can transfer messages from the network output stream of one agent to the network input stream of another, as specified by the following GLP program template, assuming the network process holds in position $p$ the paired channel of the network channel of $p$, for every $p\in P$.  A full 3-way switch is shown as Program~\ref{program:3-way-network-switch} in Appendix~\ref{appendix:additional-techniques}.



\Program{Network switch, representative clause}~\label{program:switch}
\begin{small}
\begin{verbatim}
% clause for forwarding a message from p to q:
network(...,(p,Chp),...,(q,Chq),.... :-
    receive(Chp?,msg(q,X),Chp1),
    send(Chq?,X?,Chq1) |
    network(...,(p,Chp1?),...,(q,Chq1?),....)
\end{verbatim}
\end{small}


The Network transaction defined below causes the multiagent GLP system to behave as if agents' network channels were paired to such a \verb|network| process that routes messages between them: Messages sent to agent $q$ via agent $p$'s network output stream appear on agent $q$'s network input stream, realizing communication as specified by the \verb|network| program.  However, the network is not another GLP agent; the purpose of the \verb|network| program is solely to provide  behavioural specification for the network.  

To avoid notational clutter, the Network binary transition below refers to the operation of \verb|network| verbally. It is activated when agent $p$ binds its network output stream tail to a list cell with head \verb|msg|$(q,X)$, as specified by the \verb|network|.

We leave the specification of `user' open; assuming people have free will, their behaviour cannot be specified in GLP:)  However, users testing or simulating a multiagent GLP program with specific social behaviours can of course be programmed in GLP.

\begin{definition}[Multiagent GLP]\label{definition:maGLP}
The \temph{maGLP transition system} over agents $P\subset \Pi$ and GLP module $M$ is the multiagent transition system over multiagent asynchronous resolvents over $M$ induced by the following transactions $c\rightarrow c'$:
\begin{enumerate}
    \item \textbf{Reduce $p$:} $c_p\rightarrow c'_p$ is a GLP Reduce transition, $\forall p\in P$
    \item \textbf{Communicate $p$ to $q$:}  $c_p=(G_p,\sigma_p)$, $c_q=(G_q,\sigma_q)$, $\{X?:=T\} \in \sigma_p$, $X?$ occurs in $G_q$, $c'_p=(G_p,\sigma_p \setminus \{X?:=T\})$, and $c'_q=(G_q\{X?:=T\},\sigma_q)$, $\forall p,q \in P$  (including $p=q$)
    \item \textbf{Network $p$ to $q$:} The network output stream in $c_p$ has a new message \verb|msg|$(q,X)$, $c'_p$ is the result of advancing the network output stream in $c_p$ and $c'_q$ is the result of adding $X?$ to the network input stream in $c_q$.
\end{enumerate}
\end{definition}
Note that Reduce is unary while Communicate and Network are binary. Both transfer assignments from writers to readers: Communicate operates between agents sharing logic variables, while Network operates through the network input/output streams established in each agent's initial configuration.  Still, Network and Communicate are essentially identical:  in both cases an assignment to a writer in $p$ results in its application to a reader in $q$.

To show that maGLP computations are deductions, $L$ is augmented so that the resolvent is the union of all local resolvents, the initial goal includes also a \verb|network| goal with  $|P|$ channels paired correctly to each agent's initial network channels as in Program~\ref{program:network}, and the module $M$ is augmented with the GLP definition of  \verb|network|.   

\begin{proposition}[Safety Properties of maGLP]\label{proposition:maGLP-safety}
The safety properties established for GLP in Section~\ref{section:GLP} extend directly to maGLP:
\begin{enumerate}
\item \textbf{SRSW Invariant} (cf. Proposition~\ref{proposition:srsw-preservation}): If the initial goals of all agents in a maGLP run satisfy the SRSW requirement, then every goal in every agent's resolvent throughout the run satisfies the SRSW requirement.
\item \textbf{Acyclicity} (cf. Proposition~\ref{proposition:acyclicity}): If the initial goals of all agents contain no circular terms, then no goal in any agent's resolvent contains a circular term.
\item \textbf{Monotonicity} (cf. Proposition~\ref{proposition:GLP-monotonicity}): If atom $A$ in agent $p$'s resolvent can reduce with clause $C$ at step $i$, then at any step $j > i$, either $A$ has been reduced or there exists $A'$ in $p$'s resolvent where $A' = A\tau$ for some reader substitution $\tau$, and $A'$ can reduce with $C$.
\end{enumerate}
\end{proposition}
The proofs are identical to those for single-agent GLP, substituting "agent $p$'s resolvent" for "resolvent" and noting that Reduce transitions operate locally within each agent whilst Communicate transitions preserve the properties through binary assignment transfer.


\subsection{Multiagent GLP is Grassroots}

\mypara{Overview}
Here we prove that multiagent GLP is indeed \emph{grassroots}~\cite{shapiro2023grassrootsBA}. To do so, we recall necessary mathematical foundations:
\begin{enumerate}
    \item \textbf{Protocols:} The notion of grassroots applies to protocols: A \emph{protocol} $\calF$ is an infinite family of multiagent transition systems, 
$\calF(P)$  for each set of agents $P\subset\Pi$.
    \item \textbf{Grassroots:} Informally, proving that a protocol $\calF$ is grassroots requires proving for that for any two sets of agents $P\subset P'\subset \Pi$:
        \begin{enumerate}
            \item \textbf{Oblivious:}  Any behaviours available to agents $P$ according to $\calF(P)$ are also available to them  when they operate within $P'$, namely in $\calF(P')$ 
            \item \textbf{Interactive:}  There are behaviours available to agents $P$ operating within  $P'\supset P$ not available when they operate on their own in $\calF(P)$
        \end{enumerate}
\end{enumerate}
We proceed with the definitions.

\begin{definition}[Local-states function]\label{definition:local-states}
A \temph{local-states function} $S: 2^\Pi \mapsto 2^\mathcal{S}$ maps every set of agents $P \subset \Pi$ to a set of local states $S(P) \subset \mathcal{S}$ that includes a designated initial state $s0 \in \mathcal{S}$ and satisfies $P \subset P' \subset \Pi \implies S(P) \subset S(P')$.
\end{definition}

\begin{definition}[Protocol]\label{definition:protocol}
A \temph{protocol} $\mathcal{F}$ over a local-states function $S$ is a family of multiagent transition systems that has exactly one mts $\mathcal{F}(P) = (C(P), c_0(P), T(P))$ for every $P \subset \Pi$, where $c_p \in S(P)$ and  $c0(P)_p = s0$ for every $c\in C(P)$ and $p\in P$.
\end{definition}

Note that maGLP over $M$ and $S$ is a protocol, parameterized by $P$. Next we recall the notion of a grassroots protocol.

\begin{definition}[Projection]\label{definition:projection}
Let $\emptyset \subset P \subset P' \subset \Pi$. If $c'$ is a configuration over $P'$ then $c'/P$, the \temph{projection of $c'$ over $P$}, is the configuration $c$ over $P$ defined by $c_p := c'_p$ for every $p \in P$.
\end{definition}
Note that in the definition above, $c_p$, the state of $p$ in $c$, is in $S(P')$, not in $S(P)$, and hence may include elements ``alien'' to $P$, e.g., logic variables shared with $q \in P' \setminus P$.

We use the notions of projection and closure (Definition \ref{definition:closure}) to define when a protocol is grassroots:

\begin{definition}[Oblivious, Interactive, Grassroots]\label{definition:grassroots}
A protocol $\mathcal{F}$ is:
\begin{enumerate}
    \item \temph{oblivious} if for every $\emptyset \subset P \subset P' \subseteq \Pi$, 
    $T(P){\uparrow}P'\subseteq T(P')$
    \item \temph{interactive} if for every $\emptyset \subset P \subset P' \subseteq \Pi$ and every configuration $c\in C(P')$ such that $c/P\in C(P)$, there is a computation $c\xrightarrow{*} c'$ of $\mathcal{F}(P')$ for which $c'/P\notin C(P)$.
    \item \temph{grassroots} if it is oblivious and interactive.
\end{enumerate}
\end{definition}
For protocols defined via atomic transactions, such as maGLP, we get the oblivious property ``for free'', following from the closure construction: transactions defined over $Q \subseteq P$ extend to $P$ by having non-participants remain stationary, ensuring that behaviours available to $Q$-agents are preserved when operating within the larger set $P$.



\begin{proposition}[\cite{shapiro2025atomic}]\label{proposition:oblivious}
A transactions-based protocol is oblivious. 
\end{proposition}

The interactive property requires that agents in $P$ can always potentially interact with agents in $P' \setminus P$, leaving ``alien traces" in their local states that could not have been produced by $P$ operating alone.  In maGLP this is achieved by the Network transition, in which agent $q\in P'\setminus P$ sends a message with a shared logic variable to agent $p\in P$.

\begin{restatable}{theorem}{maGLPisgrassroots}\label{theorem:maGLP-grassroots}
maGLP is grassroots.    
\end{restatable}

