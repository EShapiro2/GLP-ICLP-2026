\section{Introduction}

\mypara{The democratic deficit in the digital realm}
While the physical lives of many of us are in democracies (one person, one vote), our digital lives are governed by autocracies (one person, all votes) or plutocracies (one coin, one vote).  Cloud platforms like Facebook and Uber operate under surveillance capitalism~\cite{zuboff2019age}: corporate executives embody all three branches of government, members have no civil rights, and personal information is commercially exploited with little remuneration.  Blockchain-based systems like Bitcoin and Ethereum offer decentralization but not democracy---their governance is intrinsically plutocratic, granting power in proportion to capital investment and thus exacerbating economic inequality~\cite{vitalikplutocracy}.  Looking for digital systems that offer egalitarian control and democratic governance intrinsically---not at the courtesy of an underlying autocratic or plutocratic platform---we find none.

\mypara{Grassroots platforms}
Grassroots platforms~\cite{shapiro2023grassrootsBA,shapiro2025atomic} are distributed applications designed to restore digital sovereignty to ordinary people using only their smartphones.  A distributed system is \emph{grassroots} if it is permissionless and can have autonomous, independently-deployed instances---geographically and over time---that may interoperate once interconnected.  This requires that agents can operate within their group without interference from agents outside it, while retaining the ability to interact when desired.

Grassroots platforms are run by people on their networked personal devices, who are identified cryptographically~\cite{rivest1978method}, communicate only with authenticated friends, and can participate in multiple instances of multiple platforms simultaneously.  The grassroots social graph~\cite{shapiro2023gsn} serves as both a platform in its own right and the infrastructure layer for all other grassroots platforms: nodes represent people, edges represent authenticated friendships, and connected components arise spontaneously through befriending.  Upon this foundation, grassroots social networks~\cite{shapiro2023gsn}, grassroots cryptocurrencies~\cite{shapiro2024gc}, and grassroots democratic federations~\cite{shapiro2025GF} are built.

\mypara{Why existing alternatives fail}
Federated systems like Mastodon~\cite{raman2019challenges} remain server-dependent: users are still at the mercy of server operators who control their accounts autocratically.  Global shared data structures---whether replicated (blockchains), distributed (IPFS, DHT), or pub/sub with global directories---prevent true independence, as members cannot ignore changes made by others~\cite{shapiro2023grassrootsBA}.  Single-instance architectures create lock-in: two instances would clash over global resources (domain names, boot nodes) hardwired into their code.  No community can independently bootstrap and later interoperate---they must join existing platforms on those platforms' terms.

Grassroots platforms require a different architecture: one where small groups can form and operate independently, yet coalesce into larger communities when they interconnect, all without central coordination or global consensus.

\mypara{Programming grassroots platforms}
A key challenge in implementing grassroots platforms is overcoming faulty and malicious participants~\cite{lamport1982byzantine}. Without secure language support, correct participants cannot reliably identify each other, establish secure communication channels, or verify each other's code integrity~\cite{sabt2015trusted,costan2016intel}.
While grassroots platforms have been formally specified and their properties proven~\cite{shapiro2023grassrootsBA,shapiro2023gsn,shapiro2024gc,shapiro2025GF,shapiro2025atomic}, they remain mathematical constructions without actual implementations. To the best of our knowledge, no existing programming language provides the necessary combination of distributed execution, cryptographic security, safety, and liveness guarantees required to realize these specifications. GLP aims to close the gap between mathematical specification and implementation of grassroots platforms.

\mypara{A grassroots programming language} Our goal is to design a high-level, secure, multiagent, concurrent programming language suitable for implementing grassroots platforms. To do so, the language should address:
\begin{enumerate}
\item Mutual authentication~\cite{boyd2003protocols} enabling people to identify each other and verify each other's code identity and integrity
\item Grassroots social graph formation through both cold calls (for bootstrap and connecting disconnected components) and friend-mediated introductions
\item Secure communication among friends
\item Multiagent operational semantics~\cite{shapiro2021multiagent} with atomic transactions~\cite{shapiro2025atomic} and proven security, safety and liveness
\item Useful abstractions for distributed multiagent programming in general, and metaprogramming support in particular, to enable the development of programming tools and runtime support for the language within the language.
\end{enumerate}


\mypara{GLP} We present GLP, a secure, multiagent, concurrent, logic programming language designed for implementing grassroots platforms.
GLP extends logic programs~\cite{lloyd1987foundations,sterling1994art} with paired single-reader/single-writer variables (akin to futures and promises~\cite{dauth2019futures,azadbakht2020formal}), each establishing a secure single-message communication channel between the single writer and the single reader, enabling subsequent secure multidirectional communication by sharing readers and writers in messages.

Through signed attestations at the language level, participants verify each other's identity and code integrity when befriending and communicating. These mechanisms enable both cold calls (for bootstrap and connecting disconnected components) and friend-mediated introductions (the preferred trust propagation method).

We present GLP and prove its properties in five steps, injecting illustrative programming examples along the way:
\begin{enumerate}
\item \textbf{Logic Programs:} Define a transition system-based operational semantics for logic programs (LP)~\cite{lloyd1987foundations,sterling1994art}, in which a conjunctive goal (resolvent) is transformed by nondeterministic goal/clause reductions.

\item \textbf{Concurrent GLP:} Extend LP with reader/writer pairs, which must satisfy the Single-Reader/Single-Writer requirement; extend unification to suspend upon an attempt to bind a reader; extend configurations to include pending assignments to readers; extend transitions to include the application of an assignment from a writer to its paired reader, and thus provide nondeterministic interleaving-based asynchronous operational semantics for concurrent GLP. Prove safety properties~\cite{alpern1985defining}, including that GLP computations are deductions~\cite{kowalski1974predicate,lloyd1987foundations}.  Provide GLP with deterministic `workstation implementation-ready' transition system (Appendix~\ref{appendix:irGLP}), based on which a workstation implementation of GLP can be developed to support GLP program development.

\item \textbf{Multiagent, Concurrent GLP:} Employ multiagent transition systems~\cite{shapiro2021multiagent} with atomic transactions~\cite{shapiro2025atomic} to define the operational semantics of multiagent concurrent GLP, in which goal reductions are local and assignments of shared logic variables are realized as writer-to-reader messages among agents, and prove it to be grassroots~\cite{shapiro2023grassrootsBA}.

\item \textbf{Secure, Multiagent, Concurrent GLP:} Augment agents with self-chosen keypairs and augment cross-agent communication that is encrypted, signed and attested, resulting in secure, multiagent, concurrent GLP. Prove its security as a distributed system~\cite{coulouris2011distributed} and that GLP streams enjoy the security properties of blockchains~\cite{nakamoto2008peer}.

\item \textbf{Implementation-Ready Specification:} Replace nondeterministic goal selection with deterministic scheduling, and replace abstract push-based shared-variable communication with pull-based message-passing using dynamic shared-variable tables, geared for smartphone deployment.
\end{enumerate}

The remainder of this paper is organized as follows. Section~\ref{section:lp} recalls logic programs. Section~\ref{section:GLP} extends them to concurrent GLP. Section~\ref{section:programming-examples} presents basic GLP programming techniques. Section~\ref{section:maGLP} defines multiagent GLP and proves it grassroots. Section~\ref{section:social-graph} implements the grassroots social graph cold-call and friend-mediated introduction protocols. Section~\ref{section:GLP-security} adds cryptographic security and attestations and presents security properties, including blockchain security properties of streams. Section~\ref{section:implementation} discusses smartphone implementation. Section~\ref{section:related-work} reviews related work, and Section \ref{section:conclusion} concludes.
The appendixes provide~\ref{appendix:LP-synax} LP syntax, ~\ref{appendix:proofs} proofs, ~\ref{appendix:friend-introductions} social-graph protocol properties,  ~\ref{appendix:social-networking} grassroots social networking,
~\ref{appendix:guards-system} guard and system predicates,
~\ref{appendix:additional-techniques} additional programming and metaprogramming examples, and ~\ref{appendix:irGLP} single-workstation and~\ref{appendix:irmaGLP}  networked-smartphones implementation-ready specifications of GLP.
